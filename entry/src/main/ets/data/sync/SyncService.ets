import { DatabaseHelper } from '../db/DatabaseHelper';
import { WebUtils, PreconditionFailedError } from '../network/WebUtils';
import { relationalStore, ValuesBucket } from '@kit.ArkData';
import { util } from '@kit.ArkTS';
import { DDLItem } from '../../model/DDLModels';

// å®šä¹‰å¿«ç…§çš„æ•°æ®ç»“æ„ (Interface)
interface SnapshotVer {
  ts: string;
  ctr: number;
  dev: string;
}
interface SnapshotDoc {
  id: number;
  name: string;
  start_time: string;
  end_time: string;
  is_completed: number;
  complete_time: string;
  note: string;
  is_archived: number;
  is_stared: number;
  type: string;
  habit_count: number;
  habit_total_count: number;
  calendar_event: number;
  timestamp: string;
}
interface SnapshotItem {
  uid: string;
  ver: SnapshotVer;
  deleted: boolean;
  doc: SnapshotDoc | null;
}

interface SnapshotInterface {
  ts: string;
  dev: string;
}

interface SnapshotRoot {
  version: SnapshotInterface;
  items: SnapshotItem[]; // æˆ–ä½¿ç”¨ Array<SnapshotItem>
}

export class SyncService {
  private db: DatabaseHelper;
  private web: WebUtils;
  private readonly SNAPSHOT_PATH = "Deadliner/snapshot-v1.json";

  constructor(db: DatabaseHelper, web: WebUtils) {
    this.db = db;
    this.web = web;
  }

  // ä¸šåŠ¡å±‚é’©å­
  onLocalInserted(newLocalId: number) {}
  onLocalUpdated(localId: number) {}
  onLocalDeleting(localId: number) {}

  async syncOnce(): Promise<boolean> {
    console.info("WebDAV: snapshot syncOnce start");
    try {
      return await this.syncSnapshotOnce();
    } catch (e) {
      console.warn(`Sync Failed: ${e}`);
      return false;
    }
  }

  // ============== 1) æ„é€ â€œæœ¬åœ°å¿«ç…§â€ï¼ˆåŒ…å«å¢“ç¢‘ï¼‰ ==============
  private async buildLocalSnapshot(): Promise<SnapshotRoot> {
    const store = this.db.getRdbStore(); // âš ï¸ éœ€è¦åœ¨ DatabaseHelper ä¸­æš´éœ² getRdbStore()
    if (!store) throw new Error("DB not initialized");

    const sql = `
      SELECT
        uid,
        COALESCE(deleted,0)             AS deleted,
        COALESCE(ver_ts,'1970-01-01T00:00:00Z') AS ver_ts,
        COALESCE(ver_ctr,0)             AS ver_ctr,
        COALESCE(ver_dev,'')            AS ver_dev,
        id, name, start_time, end_time, is_completed, complete_time, note,
        is_archived, is_stared, type, habit_count, habit_total_count, calendar_event, timestamp
      FROM ddl_items
    `;

    const resultSet = await store.querySql(sql);
    const items: SnapshotItem[] = [];

    while (resultSet.goToNextRow()) {
      const uid = resultSet.getString(resultSet.getColumnIndex("uid"));
      if (!uid) continue;

      const deleted = resultSet.getLong(resultSet.getColumnIndex("deleted")) !== 0;
      const ver: SnapshotVer = {
        ts: resultSet.getString(resultSet.getColumnIndex("ver_ts")),
        ctr: resultSet.getLong(resultSet.getColumnIndex("ver_ctr")),
        dev: resultSet.getString(resultSet.getColumnIndex("ver_dev"))
      };

      let doc: SnapshotDoc | null = null;
      if (!deleted) {
        doc = {
          id: resultSet.getLong(resultSet.getColumnIndex("id")),
          name: resultSet.getString(resultSet.getColumnIndex("name")),
          start_time: resultSet.getString(resultSet.getColumnIndex("start_time")),
          end_time: resultSet.getString(resultSet.getColumnIndex("end_time")),
          is_completed: resultSet.getLong(resultSet.getColumnIndex("is_completed")),
          complete_time: resultSet.getString(resultSet.getColumnIndex("complete_time")),
          note: resultSet.getString(resultSet.getColumnIndex("note")),
          is_archived: resultSet.getLong(resultSet.getColumnIndex("is_archived")),
          is_stared: resultSet.getLong(resultSet.getColumnIndex("is_stared")),
          type: resultSet.getString(resultSet.getColumnIndex("type")),
          habit_count: resultSet.getLong(resultSet.getColumnIndex("habit_count")),
          habit_total_count: resultSet.getLong(resultSet.getColumnIndex("habit_total_count")),
          calendar_event: resultSet.getLong(resultSet.getColumnIndex("calendar_event")),
          timestamp: resultSet.getString(resultSet.getColumnIndex("timestamp")),
        };
      }

      items.push({ uid, ver, deleted, doc });
    }
    resultSet.close();

    const deviceId = await this.db.getDeviceId();
    const nowTs = new Date().toISOString();

    return {
      version: { ts: nowTs, dev: deviceId },
      items: items
    };
  }

  // ============== 2) åˆå¹¶ï¼ˆLWWï¼šts > ctr > devï¼‰ ==============
  // çº¯é€»è¾‘åˆå¹¶ï¼šä¸æ¶‰åŠ IO
  private mergeSnapshots(local: SnapshotRoot, remote: SnapshotRoot): SnapshotRoot {
    const map = new Map<string, SnapshotItem>();

    // è¾…åŠ©ï¼šåŠ è½½ items åˆ° map
    const load = (root: SnapshotRoot) => {
      if (root.items && Array.isArray(root.items)) {
        for (const item of root.items) {
          map.set(item.uid, item);
        }
      }
    };

    // å…ˆå…¨éƒ¨åŠ è½½ local
    load(local);

    // éå† remote è¿›è¡Œ LWW å†³æ–­
    if (remote.items && Array.isArray(remote.items)) {
      for (const rItem of remote.items) {
        const lItem = map.get(rItem.uid);
        if (!lItem) {
          // æœ¬åœ°æ²¡æœ‰ï¼Œç›´æ¥ç”¨è¿œç«¯
          map.set(rItem.uid, rItem);
        } else {
          // å†²çªï¼šLWW
          if (this.newer(rItem, lItem)) {
            map.set(rItem.uid, rItem);
          }
          // else: local is newer, keep local
        }
      }
    }

    // è½¬æ¢ä¸º Array
    const outItems = Array.from(map.values());

    // è¿”å›åˆå¹¶åçš„ç»“æ„ (ç‰ˆæœ¬å·å– Local çš„å½“å‰æ—¶é—´)
    return {
      version: {
        ts: local.version.ts, // Use local new timestamp
        dev: local.version.dev
      },
      items: outItems
    };
  }

  // ============== 3) åº”ç”¨â€œæœ€ç»ˆå¿«ç…§â€åˆ°æœ¬åœ° DB ==============
  // æå– newer é€»è¾‘ï¼Œæ–¹ä¾¿å¤ç”¨
  // åˆ¤æ–­ a æ˜¯å¦æ¯” b æ–°
  private isVerNewer(aVer: SnapshotVer, bVer: SnapshotVer): boolean {
    if (aVer.ts !== bVer.ts) return aVer.ts > bVer.ts;
    if (aVer.ctr !== bVer.ctr) return aVer.ctr > bVer.ctr;
    return aVer.dev >= bVer.dev;
  }

  // ä¿®æ”¹åŸæœ‰çš„ newer æ–¹æ³•ï¼Œè°ƒç”¨ä¸Šé¢çš„é€šç”¨é€»è¾‘
  private newer(a: SnapshotItem, b: SnapshotItem): boolean {
    return this.isVerNewer(a.ver, b.ver);
  }

  // =====================================================
  // ğŸ”¥ğŸ”¥ğŸ”¥ æ ¸å¿ƒä¿®å¤ï¼šapplySnapshotToLocal ğŸ”¥ğŸ”¥ğŸ”¥
  // =====================================================
  private async applySnapshotToLocal(merged: SnapshotRoot) {
    const store = this.db.getRdbStore();
    if (!store || !merged.items) return;

    store.beginTransaction();
    let insertCount = 0;
    let updateCount = 0;
    let skipCount = 0; // ç»Ÿè®¡è¢«è·³è¿‡çš„ï¼ˆä¿æŠ¤æœ¬åœ°æ–°ä¿®æ”¹çš„ï¼‰

    try {
      for (const item of merged.items) {
        const uid = item.uid;
        const mergedVer = item.ver; // è¿™æ˜¯åŒæ­¥è®¡ç®—å‡ºçš„ç‰ˆæœ¬
        const deleted = item.deleted;

        // 1. æŸ¥è¯¢æœ¬åœ°å½“å‰çš„å®é™…çŠ¶æ€
        const predicates = new relationalStore.RdbPredicates("ddl_items");
        predicates.equalTo("uid", uid);
        const resultSet = await store.query(predicates);
        const exists = resultSet.goToFirstRow();

        let localId: number | null = null;
        let currentLocalVer: SnapshotVer | null = null;

        if (exists) {
          localId = resultSet.getLong(resultSet.getColumnIndex("id"));
          // è¯»å–å½“å‰ DB é‡Œçš„ç‰ˆæœ¬å·
          currentLocalVer = {
            ts: resultSet.getString(resultSet.getColumnIndex("ver_ts")),
            ctr: resultSet.getLong(resultSet.getColumnIndex("ver_ctr")),
            dev: resultSet.getString(resultSet.getColumnIndex("ver_dev"))
          };
        }
        resultSet.close();

        // 2. ğŸ›¡ï¸ğŸ›¡ï¸ğŸ›¡ï¸ ç«æ€ä¿æŠ¤ ğŸ›¡ï¸ğŸ›¡ï¸ğŸ›¡ï¸
        // å¦‚æœæœ¬åœ°å­˜åœ¨ï¼Œä¸”æœ¬åœ°ç°åœ¨çš„ç‰ˆæœ¬ æ¯” åˆå¹¶ç»“æœçš„ç‰ˆæœ¬ è¿˜è¦æ–°
        // è¯´æ˜åœ¨åŒæ­¥æœŸé—´ï¼Œç”¨æˆ·ä¿®æ”¹äº†è¿™æ¡æ•°æ®ã€‚
        // æ­¤æ—¶ç»å¯¹ä¸èƒ½è¦†ç›–ï¼Œä¿ç•™æœ¬åœ°çš„ä¿®æ”¹ï¼
        if (currentLocalVer && this.isVerNewer(currentLocalVer, mergedVer)) {
          console.warn(`[Sync] Race detected for uid=${uid.slice(0,6)}. Local is newer, skipping overwrite.`);
          skipCount++;
          continue; // è·³è¿‡è¿™ä¸€æ¡çš„å†™å…¥
        }

        // 3. æ­£å¸¸å†™å…¥é€»è¾‘ (å’Œä¹‹å‰ä¸€æ ·)
        const bucket: ValuesBucket = {};
        bucket["ver_ts"] = mergedVer.ts;
        bucket["ver_ctr"] = mergedVer.ctr;
        bucket["ver_dev"] = mergedVer.dev;

        if (deleted) {
          bucket["deleted"] = 1;
          if (exists) {
            const upPred = new relationalStore.RdbPredicates("ddl_items");
            upPred.equalTo("id", localId);
            await store.update(bucket, upPred);
            updateCount++;
          } else {
            // æ’å…¥å¢“ç¢‘
            bucket["uid"] = uid;
            bucket["name"] = "(deleted)";
            bucket["start_time"] = ""; bucket["end_time"] = ""; bucket["complete_time"] = "";
            bucket["note"] = ""; bucket["type"] = "task"; bucket["timestamp"] = mergedVer.ts;
            bucket["is_completed"] = 1; bucket["is_archived"] = 1; bucket["is_stared"] = 0;
            bucket["habit_count"] = 0; bucket["habit_total_count"] = 0; bucket["calendar_event"] = -1;
            await store.insert("ddl_items", bucket);
            insertCount++;
          }
        } else {
          const doc = item.doc!;
          bucket["deleted"] = 0;
          bucket["name"] = doc.name;
          bucket["start_time"] = doc.start_time;
          bucket["end_time"] = doc.end_time;
          bucket["is_completed"] = doc.is_completed;
          bucket["complete_time"] = doc.complete_time;
          bucket["note"] = doc.note;
          bucket["is_archived"] = doc.is_archived;
          bucket["is_stared"] = doc.is_stared;
          bucket["type"] = doc.type;
          bucket["habit_count"] = doc.habit_count;
          bucket["habit_total_count"] = doc.habit_total_count;
          bucket["calendar_event"] = doc.calendar_event;
          bucket["timestamp"] = doc.timestamp;

          if (exists) {
            const upPred = new relationalStore.RdbPredicates("ddl_items");
            upPred.equalTo("id", localId);
            await store.update(bucket, upPred);
            updateCount++;
          } else {
            bucket["uid"] = uid;
            await store.insert("ddl_items", bucket);
            insertCount++;
          }
        }
      }
      store.commit();
      console.info(`[Sync] Apply done. Ins:${insertCount}, Upd:${updateCount}, Skipped(Race):${skipCount}`);
    } catch (e) {
      console.error(`[Sync] Apply failed: ${e}`);
      store.rollBack();
    }
  }

  // ============== 4) æ ¸å¿ƒæµç¨‹ï¼šä¸€æ¬¡å®Œæ•´åŒæ­¥ ==============
  private async syncSnapshotOnce(): Promise<boolean> {
    const path = this.SNAPSHOT_PATH;

    // 1. æ„å»ºæœ¬åœ°å¿«ç…§
    const localSnap = await this.buildLocalSnapshot();
    console.info(`[Sync] Local snapshot built. Items: ${localSnap.items.length}`);

    const textEncoder = new util.TextEncoder();
    const textDecoder = util.TextDecoder.create('utf-8');

    // 2. HEAD æ¢æµ‹
    let remoteCode = 0;
    try {
      const WebHead = await this.web.head(path);
      const code = WebHead.code;
      remoteCode = code;
      console.info(`[Sync] HEAD ${path} -> Code: ${code}`);
    } catch (e) {
      console.error(`[Sync] HEAD failed: ${e}`);
      return false;
    }

    // 3. å¤„ç† 404/409/410 -> è§†ä¸ºæ–‡ä»¶ä¸å­˜åœ¨ï¼Œç›´æ¥ä¸Šä¼ æœ¬åœ°å¿«ç…§
    if ([404, 409, 410].includes(remoteCode)) {
      console.warn(`[Sync] Remote file not found (Code ${remoteCode}). Initializing cloud with local data...`);

      try {
        await this.web.ensureDir("Deadliner");
        const jsonStr = JSON.stringify(localSnap);
        const bytes = textEncoder.encodeInto(jsonStr);
        // If-None-Match: * ç¡®ä¿åŸå­åˆ›å»º
        await this.web.putBytes(path, bytes, null, true);
        console.info(`[Sync] Uploaded local snapshot (Init).`);
        return true;
      } catch (e) {
        console.error(`[Sync] Init upload failed: ${e}`);
        return false;
      }
    }

    if (remoteCode >= 500) {
      console.warn("[Sync] Server Error, skip sync");
      return false;
    }

    // 4. GET ä¸‹è½½è¿œç«¯å¿«ç…§
    let remoteSnap: SnapshotRoot;
    let currentEtag: string | null = null;

    try {
      console.info(`[Sync] Downloading from ${path}...`);

      const webBytes = await this.web.getBytes(path);
      const bytes = webBytes.bytes;
      const etag = webBytes.etag;

      console.info(`[Sync] Downloaded ${bytes.length} bytes. ETag: ${etag}`);

      const jsonStr = textDecoder.decodeWithStream(bytes);
      remoteSnap = JSON.parse(jsonStr) as SnapshotRoot;

      console.info(`[Sync] Remote parsed. Items: ${remoteSnap.items?.length}`);

      currentEtag = etag;
    } catch (e) {
      const msg = `${e}`;
      // å¦‚æœ GET å˜æˆäº† 409ï¼Œå½“ä½œç©ºè¿œç«¯å¤„ç†
      if (msg.includes('409')) {
        remoteSnap = { version: { ts: '1970', dev: 'unknown' }, items: [] };
      } else {
        console.error(`GET failed: ${e}`);
        return false;
      }
    }

    // 5. åˆå¹¶
    let merged = this.mergeSnapshots(localSnap, remoteSnap);
    console.info(`[Sync] Merged result. Items: ${merged.items.length}`);

    let mergedJson = JSON.stringify(merged);
    let mergedBytes = textEncoder.encodeInto(mergedJson);

    // 6. PUT å›ä¼  (å¸¦ If-Match ä¹è§‚é”)
    try {
      await this.web.putBytes(path, mergedBytes, currentEtag, false);
    } catch (e) {
      if (e instanceof PreconditionFailedError) {
        // 7. å‘ç”Ÿå†²çª (412)ï¼Œé‡æ–°ä¸‹è½½ -> å†æ¬¡åˆå¹¶ -> å†æ¬¡ä¸Šä¼ 
        console.warn("Conflict (412), retrying...");
        const retryGet = await this.web.getBytes(path);
        const retryRemoteSnap = JSON.parse(textDecoder.decodeWithStream(retryGet.bytes)) as SnapshotRoot;

        // äºŒæ¬¡åˆå¹¶
        merged = this.mergeSnapshots(merged, retryRemoteSnap); // ç”¨ä¸Šæ¬¡åˆå¹¶çš„ç»“æœå†å»åˆå¹¶æ–°çš„è¿œç«¯
        mergedJson = JSON.stringify(merged);
        mergedBytes = textEncoder.encodeInto(mergedJson);

        // å¼ºåˆ¶ä¸Šä¼  (æˆ–è€…å†è¯•ä¸€æ¬¡ If-Matchï¼Œè¿™é‡Œç®€åŒ–ä¸ºç”¨æ–°çš„ ETag ä¼ )
        await this.web.putBytes(path, mergedBytes, retryGet.etag, false);
      } else {
        throw new Error(e);
      }
    }

    // 8. åº”ç”¨æœ€ç»ˆç»“æœåˆ°æœ¬åœ°
    console.info(`[Sync] Applying to local DB...`);
    await this.applySnapshotToLocal(merged);
    console.info(`[Sync] Apply done.`);

    return true;
  }
}
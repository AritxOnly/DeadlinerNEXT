import { DatabaseHelper, DDLInsertParams } from '../db/DatabaseHelper';
import { SyncService } from '../sync/SyncService';
import { WebUtils } from '../network/WebUtils';
import { LocalValues } from '../local/LocalValues';
import { DDLItem, DeadlineType } from '../../model/DDLModels';
import { common } from '@kit.AbilityKit';
import { WidgetUpdater } from '../../utils/WidgetUpdater';

export class TaskRepository {
  private static instance: TaskRepository;
  private db: DatabaseHelper;
  private context: common.Context | null = null;

  // å»æŠ–åŠ¨å®šæ—¶å™¨
  private syncTimer: number = -1;
  private readonly SYNC_DELAY_MS = 400;

  // Widget æ›´æ–°çš„é˜²æŠ–å®šæ—¶å™¨
  private widgetUpdateTimer: number = -1;
  private readonly WIDGET_UPDATE_DELAY_MS = 500;

  // ğŸ”¥ æ–°å¢ï¼šå¹¶å‘æ§åˆ¶çŠ¶æ€
  private isSyncing: boolean = false;      // æ˜¯å¦æ­£åœ¨åŒæ­¥ä¸­
  private hasPendingSync: boolean = false; // æ˜¯å¦åœ¨åŒæ­¥æœŸé—´åˆæœ‰æ–°è¯·æ±‚

  private constructor() {
    this.db = DatabaseHelper.getInstance();
  }

  public static getInstance(): TaskRepository {
    if (!TaskRepository.instance) {
      TaskRepository.instance = new TaskRepository();
    }
    return TaskRepository.instance;
  }

  public setContext(context: common.Context) {
    this.context = context;
  }

  private async ensureDbReady(): Promise<void> {
    if (this.db.isReady()) return;

    console.warn('[TaskRepo] DB not ready. Polling...');
    if (this.context) {
      this.db.init(this.context);
    }

    const maxRetries = 40;
    for (let i = 0; i < maxRetries; i++) {
      if (this.db.isReady()) return;
      await new Promise<void>(resolve => setTimeout(resolve, 50));
    }
    throw new Error('[TaskRepo] Fatal: DB Init Timeout.');
  }

  // ==========================================
  // æ ¸å¿ƒï¼šè°ƒåº¦é€»è¾‘ (é˜²æŠ– + ä¸²è¡ŒåŒ–)
  // ==========================================
  private scheduleSync() {
    // 1. é˜²æŠ–ï¼šå¦‚æœæœ‰æœªæ‰§è¡Œçš„å®šæ—¶å™¨ï¼Œé‡ç½®å®ƒ
    if (this.syncTimer !== -1) {
      clearTimeout(this.syncTimer);
    }

    // 2. æ£€æŸ¥å¼€å…³
    if (!LocalValues.getInstance().getCloudSyncEnable()) {
      return;
    }

    // 3. å¯åŠ¨å®šæ—¶å™¨
    this.syncTimer = setTimeout(() => {
      this.performSync();
    }, this.SYNC_DELAY_MS);
  }

  /**
   * çœŸæ­£æ‰§è¡ŒåŒæ­¥çš„æ–¹æ³• (ä¸²è¡Œæ§åˆ¶)
   */
  private async performSync() {
    // A. å¦‚æœå½“å‰æ­£åœ¨åŒæ­¥ï¼Œä¸è¦æ‰“æ–­ï¼Œæ ‡è®°â€œç¨åå†è¯•â€å¹¶é€€å‡º
    if (this.isSyncing) {
      console.info('[TaskRepo] Sync is running. Marking pending...');
      this.hasPendingSync = true;
      return;
    }

    // B. å¼€å§‹åŒæ­¥
    this.isSyncing = true;
    this.hasPendingSync = false; // æ¸…é™¤æ ‡è®°

    console.info('[TaskRepo] Starting auto-sync...');

    try {
      const GeneratedDestructObj_1 = LocalValues.getInstance().getWebDavAuth();
      const user = GeneratedDestructObj_1.user;
      const pass = GeneratedDestructObj_1.pass;
      const url = LocalValues.getInstance().getWebDavUrl();

      if (url) {
        const web = new WebUtils(url, user, pass);
        const syncService = new SyncService(this.db, web);

        await syncService.syncOnce();

        console.info('[TaskRepo] Auto-sync success.');

        // ğŸ”¥ ä¿®å¤ï¼šä½¿ç”¨ä¿å­˜çš„ context å‘é€äº‹ä»¶ï¼Œé€šçŸ¥ UI åˆ·æ–°
        if (this.context) {
          this.context.eventHub.emit('sync_done');
        }
      }
    } catch (e) {
      console.error(`[TaskRepo] Auto-sync failed: ${e}`);
    } finally {
      // C. åŒæ­¥ç»“æŸï¼Œé‡Šæ”¾é”
      this.isSyncing = false;

      // D. æ£€æŸ¥åœ¨åŒæ­¥æœŸé—´æ˜¯å¦æœ‰æ–°è¯·æ±‚
      if (this.hasPendingSync) {
        console.info('[TaskRepo] Found pending request. Syncing again immediately...');
        // é€’å½’è°ƒç”¨ï¼ˆæˆ–è€…å†æ¬¡ setTimeoutï¼‰ï¼Œå¤„ç†ç§¯å‹çš„å˜æ›´
        this.performSync();
      }
    }
  }

  // ==========================================
  // å¢åˆ æ”¹æŸ¥
  // ==========================================

  async insertDDL(params: DDLInsertParams): Promise<number> {
    await this.ensureDbReady();
    const id = await this.db.insertDDL(params);
    this.scheduleSync(); // è§¦å‘è°ƒåº¦
    this.scheduleWidgetUpdate();
    return id;
  }

  async updateDDL(item: DDLItem): Promise<void> {
    await this.ensureDbReady();
    await this.db.updateDDL(item);
    this.scheduleSync(); // è§¦å‘è°ƒåº¦
    this.scheduleWidgetUpdate();
  }

  async deleteDDL(id: number): Promise<void> {
    await this.ensureDbReady();
    await this.db.deleteDDL(id);
    this.scheduleSync(); // è§¦å‘è°ƒåº¦
    this.scheduleWidgetUpdate();
  }

  async getAllDDLs(): Promise<DDLItem[]> {
    await this.ensureDbReady();
    return this.db.getAllDDLs();
  }

  async getDDLsByType(type: DeadlineType): Promise<DDLItem[]> {
    await this.ensureDbReady();
    return this.db.getDDLsByType(type);
  }

  private scheduleWidgetUpdate() {
    // 1. å¦‚æœå·²æœ‰æŒ‚èµ·çš„æ›´æ–°ä»»åŠ¡ï¼Œå–æ¶ˆå®ƒï¼ˆé‡æ–°è®¡æ—¶ï¼‰
    if (this.widgetUpdateTimer !== -1) {
      clearTimeout(this.widgetUpdateTimer);
    }

    // 2. å¯åŠ¨æ–°çš„å®šæ—¶å™¨
    this.widgetUpdateTimer = setTimeout(() => {
      this.performWidgetUpdate();
    }, this.WIDGET_UPDATE_DELAY_MS);
  }

  private performWidgetUpdate() {
    const context = this.context;
    if (context) {
      console.info('[TaskRepo] Updating widgets now...');
      WidgetUpdater.updateAllWidgets(context);
    }
    this.widgetUpdateTimer = -1;
  }

  // ==========================================
  // æ‰‹åŠ¨åŒæ­¥
  // ==========================================
  async syncNow(): Promise<boolean> {
    await this.ensureDbReady();

    // å–æ¶ˆç”±äºé˜²æŠ–æŒ‚èµ·çš„ä»»åŠ¡ï¼Œç›´æ¥æ’é˜Ÿæ‰§è¡Œ
    if (this.syncTimer !== -1) {
      clearTimeout(this.syncTimer);
      this.syncTimer = -1;
    }

    // å¤ç”¨ä¸²è¡Œé€»è¾‘ï¼Œé˜²æ­¢æ‰‹åŠ¨å’Œè‡ªåŠ¨å†²çª
    // ä½† syncNow éœ€è¦è¿”å›ç»“æœï¼Œæ‰€ä»¥è¿™é‡Œç‰¹æ®Šå¤„ç†ä¸€ä¸‹ï¼Œç­‰å¾… performSync å®Œæˆä¸å¤ªå®¹æ˜“
    // ç®€å•èµ·è§ï¼Œæ‰‹åŠ¨åŒæ­¥å¼ºåˆ¶æ‰§è¡Œé€»è¾‘ï¼ˆéœ€æ³¨æ„ï¼Œå¦‚æœæ­£åœ¨è‡ªåŠ¨åŒæ­¥ï¼Œå¯èƒ½ä¼šå†²çªï¼Œ
    // æ›´å¥½çš„åšæ³•æ˜¯è®© syncNow ä¹Ÿèµ° performSync é€»è¾‘ï¼Œæˆ–è€…ç­‰å¾…é”é‡Šæ”¾ï¼‰

    // è¿™é‡Œé‡‡ç”¨ç®€å•ç­–ç•¥ï¼šå¦‚æœæ­£åœ¨åŒæ­¥ï¼Œç›´æ¥æŠ¥é”™æˆ–è¿”å› false
    if (this.isSyncing) {
      console.warn('[TaskRepo] Sync already running. Manual sync ignored.');
      return false;
    }

    this.isSyncing = true;
    try {
      const webAuth = LocalValues.getInstance().getWebDavAuth();
      const user = webAuth.user;
      const pass = webAuth.pass;
      const url = LocalValues.getInstance().getWebDavUrl();
      if (!url) return false;

      const web = new WebUtils(url, user, pass);
      const syncService = new SyncService(this.db, web);
      const result = await syncService.syncOnce();

      if (result && this.context) {
        this.context.eventHub.emit('sync_done');
        this.performWidgetUpdate();
      }
      return result;
    } finally {
      this.isSyncing = false;
      // æ‰‹åŠ¨åŒæ­¥å®Œï¼Œä¹Ÿæ£€æŸ¥ä¸€ä¸‹pending
      if (this.hasPendingSync) {
        this.performSync();
      }
    }
  }
}
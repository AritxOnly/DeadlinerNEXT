import { http } from '@kit.NetworkKit';
import { util } from '@kit.ArkTS';
import { BusinessError } from '@kit.BasicServicesKit';
import { LocalValues } from '../local/LocalValues';

// ç®€å•çš„è‡ªå®šä¹‰å¼‚å¸¸ï¼Œç”¨äºæ¨¡æ‹Ÿ PreconditionFailed
export class PreconditionFailedError extends Error {
  constructor(message: string = "Precondition Failed") {
    super(message);
    this.name = "PreconditionFailedError";
  }
}

interface HeadReturnValues {
  code: number;
  etag: string | null;
  len: number | null;
}

interface GetBytesReturnValues {
  bytes: Uint8Array;
  etag: string | null;
}

interface GetRangeReturnValues {
  bytes: Uint8Array;
  etag: string | null;
  newOffset: number;
}

export class WebUtils {
  private baseUrl: string;
  private authHeader: string | null = null;
  // æ¨¡æ‹Ÿ GlobalUtils.cloudSyncEnableï¼Œå®é™…è¯·æ›¿æ¢ä¸ºä½ çš„é…ç½®è¯»å–é€»è¾‘
  public static cloudSyncEnable: boolean = true;

  constructor(baseUrl: string, username?: string, password?: string) {
    this.baseUrl = baseUrl.endsWith('/') ? baseUrl : baseUrl + '/';
    if (username && password) {
      const textEncoder = new util.TextEncoder();
      const origin = `${username}:${password}`;
      const uint8Array = textEncoder.encodeInto(origin);
      const base64Helper = new util.Base64Helper();
      this.authHeader = `Basic ${base64Helper.encodeToStringSync(uint8Array)}`;
    }
  }

  private ensureSyncEnabled() {
    // ä» SettingsValue è·å–çœŸå®é…ç½®
    const isEnabled = LocalValues.getInstance().getCloudSyncEnable();
    if (!isEnabled) {
      throw new Error("Cloud sync is disabled by user.");
    }
  }

  private joinUrl(path: string): string {
    const p = path.startsWith('/') ? path.substring(1) : path;
    return `${this.baseUrl}${p}`;
  }

  private getHeaders(extra: Record<string, string> = {}): Record<string, string> {
    const headers: Record<string, string> = {};
    if (this.authHeader) {
      headers['Authorization'] = this.authHeader;
    }
    Object.keys(extra).forEach((key) => {
      headers[key] = extra[key];
    });
    return headers;
  }

  // ============== æ ¸å¿ƒæ–¹æ³• ==============

  async head(path: string): Promise<HeadReturnValues> {
    this.ensureSyncEnabled();
    const httpRequest = http.createHttp();
    const url = this.joinUrl(path);

    try {
      const resp = await httpRequest.request(url, {
        method: http.RequestMethod.HEAD,
        header: this.getHeaders(),
        expectDataType: http.HttpDataType.STRING
      });

      // Header key å¯èƒ½æ˜¯å°å†™ï¼Œéœ€æ³¨æ„
      const etag = this.getHeader(resp.header, 'ETag');
      const lenStr = this.getHeader(resp.header, 'Content-Length');
      const len = lenStr ? parseInt(lenStr) : null;

      return { code: resp.responseCode, etag, len };
    } finally {
      httpRequest.destroy();
    }
  }

  async getBytes(path: string): Promise<GetBytesReturnValues> {
    this.ensureSyncEnabled();
    const httpRequest = http.createHttp();
    const url = this.joinUrl(path);

    try {
      const resp = await httpRequest.request(url, {
        method: http.RequestMethod.GET,
        header: this.getHeaders(),
        expectDataType: http.HttpDataType.ARRAY_BUFFER // ğŸ‘ˆ å¿…é¡»æ˜¾å¼å£°æ˜æ¥æ”¶ ArrayBuffer
      });

      if (resp.responseCode !== 200) {
        throw new Error(`GET ${path} -> ${resp.responseCode}`);
      }

      const etag = this.getHeader(resp.header, 'ETag');

      // ğŸ”¥ ä¿®å¤ï¼šç¡®ä¿ç»“æœæ˜¯ ArrayBufferï¼Œå¹¶è½¬ä¸º Uint8Array
      let resultBuffer: ArrayBuffer;
      if (resp.result instanceof ArrayBuffer) {
        resultBuffer = resp.result;
      } else {
        //ä»¥æ­¤é˜²èŒƒæŸäº›æƒ…å†µä¸‹è¿”å›é ArrayBuffer
        throw new Error("Response is not ArrayBuffer");
      }

      const bytes = new Uint8Array(resultBuffer);
      return { bytes, etag };
    } finally {
      httpRequest.destroy();
    }
  }

  // æ³¨æ„ï¼šArkTS http æ¨¡å—å¯¹ Range æ”¯æŒå–å†³äºæœåŠ¡ç«¯å“åº”ï¼Œè¿™é‡ŒåšåŸºç¡€å®ç°
  // åŸ Kotlin ä»£ç è¿”å›äº† newOffsetï¼Œè¿™é‡Œç®€åŒ–è¿”å›å€¼ç»“æ„
  async getRange(path: string, from: number): Promise<GetRangeReturnValues> {
    this.ensureSyncEnabled();
    const httpRequest = http.createHttp();
    const url = this.joinUrl(path);
    const headers = this.getHeaders({ 'Range': `bytes=${from}-` });

    try {
      const resp = await httpRequest.request(url, {
        method: http.RequestMethod.GET,
        header: headers,
        expectDataType: http.HttpDataType.ARRAY_BUFFER
      });

      if (resp.responseCode !== 200 && resp.responseCode !== 206) {
        throw new Error(`GET Range ${path} -> ${resp.responseCode}`);
      }

      const etag = this.getHeader(resp.header, 'ETag');
      const bytes = new Uint8Array(resp.result as ArrayBuffer);
      const newOffset = from + bytes.length;
      return { bytes, etag, newOffset };
    } finally {
      httpRequest.destroy();
    }
  }

  async putBytes(
    path: string,
    bytes: Uint8Array | string,
    ifMatch?: string | null,
    ifNoneMatchStar: boolean = false
  ): Promise<string | null> {
    this.ensureSyncEnabled();

    // å…³é”®ï¼šå…ˆæŠŠçˆ¶ç›®å½•å»ºå¥½
    const parentOk = await this.ensureParents(path);
    if (!parentOk) throw new Error(`MKCOL parents failed for ${path}`);

    const httpRequest = http.createHttp();
    const url = this.joinUrl(path);

    const headers = this.getHeaders({
      'Content-Type': 'application/json; charset=utf-8' // å»ºè®®æ˜ç¡®æŒ‡å®š JSON
    });
    if (ifMatch) headers['If-Match'] = ifMatch;
    if (ifNoneMatchStar) headers['If-None-Match'] = '*';

    // ğŸ”¥ å…³é”®ä¿®å¤ï¼šå°† Uint8Array è½¬å› ArrayBuffer ä¼ ç»™ extraData
    // ArkTS çš„ http æ¨¡å—å¯¹ ArrayBuffer çš„æ”¯æŒæœ€ç¨³å®š
    let payload: ArrayBuffer | string;
    if (typeof bytes === 'string') {
      payload = bytes;
    } else {
      // è¿™é‡Œçš„ slice æ˜¯ä¸ºäº†é˜²æ­¢ buffer åŒ…å«å¤šä½™çš„ offset
      payload = bytes.buffer.slice(bytes.byteOffset, bytes.byteOffset + bytes.byteLength);
    }

    try {
      const resp = await httpRequest.request(url, {
        method: http.RequestMethod.PUT,
        header: headers,
        extraData: payload // ğŸ‘ˆ ä¼ å…¥ ArrayBuffer
      });

      if (resp.responseCode === 412) {
        throw new PreconditionFailedError();
      }

      if (resp.responseCode < 200 || resp.responseCode >= 300) {
        throw new Error(`PUT ${path} -> ${resp.responseCode}`);
      }

      return this.getHeader(resp.header, 'ETag');
    } finally {
      httpRequest.destroy();
    }
  }

  // ============== ç›®å½•æ“ä½œ ==============

  async dirExists(dir: string): Promise<boolean> {
    const d = dir.endsWith('/') ? dir : dir + '/';
    try {
      const head = await this.head(d);
      const code = head.code;
      // 207 æ˜¯ WebDAV Multi-Statusï¼Œä¹Ÿä»£è¡¨å­˜åœ¨
      return [200, 204, 207].includes(code);
    } catch (e) {
      return false;
    }
  }

  async mkcol(dir: string): Promise<boolean> {
    const httpRequest = http.createHttp();
    const d = dir.endsWith('/') ? dir : dir + '/';
    const url = this.joinUrl(d);

    try {
      const resp = await httpRequest.request(url, {
        method: 'MKCOL' as http.RequestMethod, // WebDAV æ–¹æ³•
        header: this.getHeaders(),
        extraData: '' // å¿…é¡»æœ‰ body å¦åˆ™æŸäº› server æŠ¥é”™
      });
      // 201 Created, 405 Method Not Allowed (å¯èƒ½å·²å­˜åœ¨), 409 Conflict (å¯èƒ½å·²å­˜åœ¨)
      return [201, 405, 409].includes(resp.responseCode);
    } catch (e) {
      console.error(`MKCOL failed: ${e}`);
      return false;
    } finally {
      httpRequest.destroy();
    }
  }

  async ensureParents(filePath: string): Promise<boolean> {
    let cleanPath = filePath.trim();
    if (cleanPath.startsWith('/')) cleanPath = cleanPath.substring(1);

    const parts = cleanPath.split('/');
    if (parts.length === 0) return true;

    // å¦‚æœæœ€åä¸€æ®µåŒ…å«ç‚¹ï¼ˆè®¤ä¸ºæ˜¯æ–‡ä»¶ï¼‰ï¼Œåˆ™å»æ‰æœ€åä¸€æ®µ
    if (parts[parts.length - 1].includes('.')) {
      parts.pop();
    }
    if (parts.length === 0) return true;

    let cur = "";
    for (const seg of parts) {
      if (!seg) continue;
      cur = cur ? `${cur}/${seg}` : seg;

      const exists = await this.dirExists(cur);
      if (!exists) {
        const ok = await this.mkcol(cur);
        if (!ok) return false;
      }
    }
    return true;
  }

  async ensureDir(dirname: string): Promise<boolean> {
    if (!WebUtils.cloudSyncEnable) return false;
    // 1. HEAD
    const head = await this.head(dirname.endsWith('/') ? dirname : dirname + '/');
    const code = head.code;
    if ([200, 204, 301, 302, 207].includes(code)) return true;
    if (code === 401 || code === 403) return false;

    // 2. MKCOL
    return await this.mkcol(dirname);
  }

  // è¾…åŠ©ï¼šä¸åŒºåˆ†å¤§å°å†™è·å– Header
  private getHeader(headers: Object, key: string): string | null {
    if (!headers) return null;
    const headerMap = headers as Record<string, string | string[]>;
    const lowerKey = key.toLowerCase();

    // Object.keys åœ¨ ArkTS ä¸­æ˜¯å…è®¸çš„
    for (const k of Object.keys(headerMap)) {
      if (k.toLowerCase() === lowerKey) {
        const val = headerMap[k];
        return Array.isArray(val) ? val[0] : val;
      }
    }
    return null;
  }
}
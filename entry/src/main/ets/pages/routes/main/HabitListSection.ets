import { TopSafeContainer } from "../../components/TopSafeContainer"
import { HabitRepository } from '../../../common/repository/HabitRepository';
import { Habit, HabitGoalType, HabitPeriod, HabitRecordStatus, HabitStatus } from '../../../model/DDLModels';
import { HabitCircleProgress, WeekRow, HabitRow, DDLStatus, HabitWithDailyStatus, DayOverview } from '../../components/HabitComponents'
import { HabitListController } from "./HabitListController";
import { promptAction } from '@kit.ArkUI'
import { VibrationUtils } from "../../../utils/VibrationUtils";

@Component
export struct HabitListSection {
  @Prop topAvoidHeight: number = 0;

  scroller: Scroller = new Scroller();
  controller: HabitListController = new HabitListController();

  // â€”â€” 1. æ•°æ®æº (@State) â€”â€”
  @State selectedDate: Date = new Date();
  @State searchQuery: string = "";
  @State weekOverview: DayOverview[] = [];
  @State displayHabits: HabitWithDailyStatus[] = [];

  // å†…å­˜ç¼“å­˜
  private allHabitsCache: HabitWithDailyStatus[] = [];

  // äº¤äº’æ¨¡å¼çŠ¶æ€ï¼ˆå¯¹åº” selectionModeï¼‰
  @Link isSelectionMode: boolean;
  @State selectedDdlIds: Set<number> = new Set();

  private repo = HabitRepository.getInstance();

  // â€”â€” 2. ç”Ÿå‘½å‘¨æœŸ â€”â€”
  aboutToAppear() {
    this.refreshAll(this.selectedDate);

    if (this.controller) {
      this.bindController();
    }
  }

  private bindController() {
    this.controller.requestBatchComplete = (): Promise<void> => this.handleBatchComplete();
    this.controller.requestBatchArchive = (): Promise<void> => this.handleBatchArchive();
    this.controller.requestBatchDelete = (): Promise<void> => this.handleBatchDelete();
    this.controller.requestBatchEdit = (): void => this.handleBatchEdit();
    this.controller.requestExitSelection = (): void => this.exitSelectionMode();
  }

  // â€”â€” 3. ä¸šåŠ¡é€»è¾‘ â€”â€”

  async refreshAll(date: Date) {
    const allHabits = await this.repo.getAllHabits();

    // è®¡ç®—åˆ—è¡¨çŠ¶æ€
    const statusList = await Promise.all(allHabits.map(h => this.buildStatusForDate(h, date)));
    this.allHabitsCache = statusList;
    this.applyFilter();

    // è®¡ç®—å‘¨è§†å›¾
    this.calculateWeekOverview(date, allHabits);
  }

  private async buildStatusForDate(habit: Habit, date: Date): Promise<HabitWithDailyStatus> {
    const GeneratedDestructArray_1 = this.getPeriodBounds(habit.period, date);
    const start = GeneratedDestructArray_1[0];
    const end = GeneratedDestructArray_1[1];
    const queryStart = habit.goalType === HabitGoalType.TOTAL ? new Date(0) : start;
    const queryEnd = habit.goalType === HabitGoalType.TOTAL ? date : end;

    const records = await this.repo.getRecordsForHabitInRange(habit.id, queryStart, queryEnd);

    const done = records
      .filter(r => r.status === HabitRecordStatus.COMPLETED)
      .reduce((sum, r) => sum + r.count, 0);

    let target = Math.max(1, habit.timesPerPeriod);
    if (habit.goalType === HabitGoalType.TOTAL) {
      target = habit.totalTarget ? Math.max(1, habit.totalTarget) : Math.max(1, done);
    }

    return {
      habit: habit,
      doneCount: done,
      targetCount: target,
      isCompleted: habit.totalTarget ? done >= habit.totalTarget : done >= target
    };
  }

  private applyFilter() {
    if (!this.searchQuery || this.searchQuery.trim() === "") {
      this.displayHabits = this.allHabitsCache;
    } else {
      const lowerQ = this.searchQuery.toLowerCase();
      this.displayHabits = this.allHabitsCache.filter(it =>
      it.habit.name.toLowerCase().includes(lowerQ)
      );
    }
  }

  // æ—¥æœŸè¾…åŠ©é€»è¾‘
  private getPeriodBounds(period: HabitPeriod, date: Date): [Date, Date] {
    const d = new Date(date);
    d.setHours(0, 0, 0, 0);

    if (period === HabitPeriod.DAILY) {
      return [d, d];
    } else if (period === HabitPeriod.WEEKLY) {
      const day = d.getDay();
      const diff = d.getDate() - day + (day === 0 ? -6 : 1);
      const monday = new Date(d.setDate(diff));
      const sunday = new Date(monday);
      sunday.setDate(monday.getDate() + 6);
      return [monday, sunday];
    } else if (period === HabitPeriod.MONTHLY) {
      const firstDay = new Date(d.getFullYear(), d.getMonth(), 1);
      const lastDay = new Date(d.getFullYear(), d.getMonth() + 1, 0);
      return [firstDay, lastDay];
    }
    return [d, d];
  }

  private async calculateWeekOverview(centerDate: Date, allHabits: Habit[]) {
    const d = new Date(centerDate);
    const day = d.getDay();
    const diff = d.getDate() - day + (day === 0 ? -6 : 1);
    const monday = new Date(d.setDate(diff));

    const week: DayOverview[] = [];
    for (let i = 0; i < 7; i++) {
      const current = new Date(monday);
      current.setDate(monday.getDate() + i);

      // ç®€åŒ–è®¡ç®—ï¼šå®é™…é¡¹ç›®å¯èƒ½éœ€è¦ä¼˜åŒ–æ€§èƒ½
      const statuses = await Promise.all(allHabits.map(h => this.buildStatusForDate(h, current)));
      const completedCount = statuses.filter(s => s.isCompleted).length;
      const totalCount = allHabits.length;

      week.push({
        date: current,
        completedCount: completedCount,
        totalCount: totalCount,
        completionRatio: totalCount > 0 ? (completedCount / totalCount) : 0
      });
    }
    this.weekOverview = week;
  }

  // â€”â€” 4. äº¤äº’äº‹ä»¶ â€”â€”

  onDateSelected(date: Date) {
    this.selectedDate = date;
    this.refreshAll(date);
  }

  async onToggleHabit(item: HabitWithDailyStatus) {
    // åªæœ‰é€‰ä¸­çš„æ—¥æœŸä¸æ™šäºä»Šå¤©æ‰èƒ½æ‰“å¡
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const currentSel = new Date(this.selectedDate);
    currentSel.setHours(0, 0, 0, 0);

    if (currentSel.getTime() > today.getTime()) {
      return; // æœªæ¥æ—¥æœŸä¸å¯æ‰“å¡
    }

    if (this.isSelectionMode) {
      this.toggleSelection(item.habit.ddlId);
      return;
    }

    const beforeRate = item.doneCount / item.targetCount;
    await this.repo.toggleRecord(item.habit.id, this.selectedDate);
    await this.refreshAll(this.selectedDate);

    // åº†ç¥æ£€æµ‹
    const afterItem = this.allHabitsCache.find(it => it.habit.id === item.habit.id);
    if (afterItem) {
      const afterRate = afterItem.doneCount / afterItem.targetCount;
      if (beforeRate < 1 && afterRate >= 1) {
        console.info("ğŸ‰ Habit Completed!");
      }
    }
  }

  exitSelectionMode() {
    this.isSelectionMode = false;
    this.selectedDdlIds.clear();
  }

  async handleBatchComplete() {
    if (this.selectedDdlIds.size === 0) return;

    // ç­›é€‰å‡ºé€‰ä¸­çš„ã€ä¸”å½“å¤©è¿˜ã€æœªå®Œæˆã€‘çš„ä¹ æƒ¯
    // æ³¨æ„ï¼šallHabitsCache é‡Œå­˜çš„æ˜¯ HabitWithDailyStatusï¼ŒåŒ…å« ddlId
    const targets = this.allHabitsCache.filter(item =>
    this.selectedDdlIds.has(item.habit.ddlId) && !item.isCompleted
    );

    if (targets.length === 0) {
      promptAction.showToast({ message: 'é€‰ä¸­çš„ä¹ æƒ¯å·²å…¨éƒ¨å®Œæˆ' });
      this.exitSelectionMode();
      return;
    }

    try {
      // å¹¶è¡Œæ‰§è¡Œæ’å…¥è®°å½•
      // æ³¨æ„ï¼šè¿™é‡Œç®€å•åœ°æ’å…¥ä¸€æ¡è®°å½•ã€‚å¦‚æœéœ€è¦ç²¾ç¡®æ§åˆ¶æ¬¡æ•°ï¼ˆæ¯”å¦‚ç›®æ ‡æ˜¯3æ¬¡ï¼Œç°åœ¨æ˜¯0æ¬¡ï¼Œæ˜¯å¦ç›´æ¥åŠ æ»¡ï¼Ÿï¼‰ï¼Œ
      // ç›®å‰é€»è¾‘æ˜¯ insertRecord é»˜è®¤ count=1ã€‚
      // å¦‚æœä½ çš„â€œæ‰¹é‡å®Œæˆâ€å®šä¹‰æ˜¯â€œç›´æ¥è®¾ä¸ºè¾¾æ ‡â€ï¼Œä½ éœ€è¦è®¡ç®—ç¼ºå¤šå°‘æ¬¡ã€‚
      // è¿™é‡Œç®€åŒ–ä¸ºï¼šç›´æ¥è¡¥é½åˆ°ç›®æ ‡æ¬¡æ•° (æˆ–è€…ç®€å•åœ°åŠ ä¸€æ¬¡ï¼Œè§†ä½ çš„ä¸šåŠ¡å®šä¹‰è€Œå®š)
      // å‡è®¾ä¸šåŠ¡å®šä¹‰ï¼šæ‰¹é‡æ‰“å¡ = ç»™é€‰ä¸­çš„æ¯ä¸€é¡¹åŠ ä¸€æ¬¡æ‰“å¡
      await Promise.all(targets.map(item => {
        return this.repo.insertRecord(item.habit.id, this.selectedDate, 1);
      }));

      promptAction.showToast({ message: `å·²æ‰“å¡ ${targets.length} ä¸ªä¹ æƒ¯` });
      this.refreshAll(this.selectedDate);
      this.exitSelectionMode();
    } catch (e) {
      console.error('Batch complete failed:', e);
      promptAction.showToast({ message: 'æ“ä½œå¤±è´¥' });
    }
  }

  async handleBatchDelete() {
    if (this.selectedDdlIds.size === 0) return;

    VibrationUtils.vibrateMedium();
    // å¼¹çª—ç¡®è®¤
    AlertDialog.show({
      title: 'åˆ é™¤ä¹ æƒ¯',
      message: `ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„ ${this.selectedDdlIds.size} ä¸ªä¹ æƒ¯å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚`,
      autoCancel: true, // ç‚¹å‡»é®ç½©å±‚æ˜¯å¦å…³é—­
      alignment: DialogAlignment.Bottom, // å¼¹çª—ä½ç½®
      offset: { dx: 0, dy: -20 }, // å¾®è°ƒä½ç½®
      gridCount: 4, // å¼¹çª—å®½åº¦å ç”¨æ …æ ¼æ•°
      backgroundBlurStyle: BlurStyle.Regular,
      primaryButton: {
        value: 'å–æ¶ˆ',
        fontColor: $r('app.color.brand'), // ä½ çš„ä¸»é¢˜è‰²
        action: () => {
          // ç‚¹å‡»å–æ¶ˆï¼Œä¸åšä»»ä½•äº‹ï¼Œæˆ–è€…å¯ä»¥é€€å‡ºé€‰æ‹©æ¨¡å¼
        }
      },
      secondaryButton: {
        value: 'åˆ é™¤',
        fontColor: Color.Red,
        action: async () => {
          // ç‚¹å‡»åˆ é™¤
          try {
            const idsToDelete = Array.from(this.selectedDdlIds);
            await Promise.all(idsToDelete.map(ddlId => this.repo.deleteHabitByDdlId(ddlId)));

            promptAction.showToast({ message: 'åˆ é™¤æˆåŠŸ' });
            this.refreshAll(this.selectedDate);
            this.exitSelectionMode();
            // é€šçŸ¥å…¨å±€åˆ·æ–°
            getContext(this).eventHub.emit('sync_done');
          } catch (e) {
            console.error('Batch delete failed:', e);
            promptAction.showToast({ message: 'åˆ é™¤å¤±è´¥' });
          }
        }
      }
    })
  }

  async handleBatchArchive() {
    if (this.selectedDdlIds.size === 0) return;

    try {
      const targets = this.allHabitsCache.filter(item => this.selectedDdlIds.has(item.habit.ddlId));

      await Promise.all(targets.map(item => {
        // æ›´æ–°çŠ¶æ€ä¸º ARCHIVED
        const updatedHabit = item.habit;
        updatedHabit.status = HabitStatus.ARCHIVED;
        return this.repo.updateHabit(updatedHabit);
      }));

      promptAction.showToast({ message: `å·²å½’æ¡£ ${targets.length} ä¸ªä¹ æƒ¯` });
      this.refreshAll(this.selectedDate);
      this.exitSelectionMode();
    } catch (e) {
      console.error('Batch archive failed:', e);
      promptAction.showToast({ message: 'å½’æ¡£å¤±è´¥' });
    }
  }

  handleBatchEdit() {
    if (this.selectedDdlIds.size === 0) return;

    if (this.selectedDdlIds.size > 1) {
      promptAction.showToast({ message: 'ä¸€æ¬¡åªèƒ½ç¼–è¾‘ä¸€ä¸ªä¹ æƒ¯' });
      return;
    }

    // è·å–é€‰ä¸­çš„ ID
    const ddlId: number = this.selectedDdlIds.values().next().value;

    // é€€å‡ºé€‰æ‹©æ¨¡å¼
    this.exitSelectionMode();

    // TODO: è·³è½¬åˆ°ç¼–è¾‘é¡µ
    // è¿™é‡Œå‡è®¾ä½ æœ‰ä¸€ä¸ª EditHabitPageï¼Œéœ€è¦é€šè¿‡ router æˆ– navPathStack è·³è½¬
    // å‡è®¾å·²ç»åœ¨ MainHomePage é€šè¿‡ AppStorage å­˜äº† NavPathStackï¼Œæˆ–è€…é€šè¿‡ EventHub å‘é€
    promptAction.showToast({ message: 'ç¼–è¾‘åŠŸèƒ½å¼€å‘ä¸­...' });
    // ç¤ºä¾‹ï¼š this.pageStack.pushPath({ name: 'editHabit', param: { ddlId } })
  }

  onLongPress(ddlId: number) {
    this.isSelectionMode = true;
    this.toggleSelection(ddlId);
  }

  toggleSelection(ddlId: number) {
    if (this.selectedDdlIds.has(ddlId)) {
      this.selectedDdlIds.delete(ddlId);
      // å¦‚æœæ‰€æœ‰éƒ½å–æ¶ˆäº†ï¼Œå¯èƒ½éœ€è¦é€€å‡ºé€‰æ‹©æ¨¡å¼ï¼Œè§†éœ€æ±‚è€Œå®š
      if (this.selectedDdlIds.size === 0) {
        this.isSelectionMode = false;
      }
    } else {
      this.selectedDdlIds.add(ddlId);
    }
  }

  isSelected(ddlId: number): boolean {
    return this.selectedDdlIds.has(ddlId);
  }

  private getTodayCompletionRatio(): number {
    const todayOverview = this.weekOverview.find(
      d => d.date.toDateString() === this.selectedDate.toDateString()
    );
    return todayOverview ? todayOverview.completionRatio : 0;
  }

  // â€”â€” 5. UI æ„å»º (HabitDisplayLayout é€»è¾‘) â€”â€”
  build() {
    Column() {
      TopSafeContainer({ topAvoidHeight: this.topAvoidHeight }) {
        Column() {
          // 1. é¡¶éƒ¨è¿›åº¦ (ä½¿ç”¨æ–°ç»„ä»¶)
          HabitCircleProgress({ progress: this.getTodayCompletionRatio() })
            .margin({ top: 12, bottom: 12 })

          // 2. æœ¬å‘¨æ—¥æœŸæ¨ªæ¡ (ä½¿ç”¨æ–°ç»„ä»¶)
          WeekRow({
            weekOverview: this.weekOverview,
            selectedDate: this.selectedDate,
            onSelectDate: (d: Date): void => this.onDateSelected(d)
          })
            .margin({ bottom: 8 })

          // 3. ä¹ æƒ¯åˆ—è¡¨
          List({ scroller: this.scroller, space: 10 }) {
            ForEach(this.displayHabits, (item: HabitWithDailyStatus) => {
              ListItem() {
                // ä½¿ç”¨æ–°ç»„ä»¶ HabitRow
                HabitRow({
                  data: item,
                  status: item.isCompleted ? DDLStatus.COMPLETED : DDLStatus.UNDERGO, // ç®€å•æ˜ å°„ï¼Œå®é™…å¯è®¡ç®— DDL å‰©ä½™æ—¶é—´æ˜ å°„çŠ¶æ€
                  isSelected: this.isSelected(item.habit.ddlId),
                  canToggle: new Date(this.selectedDate).setHours(0,0,0,0) <= new Date().setHours(0,0,0,0),
                  remainingText: "", // æš‚æ—¶ç•™ç©ºæˆ–æ ¹æ®é€»è¾‘è®¡ç®—
                  onToggle: (): Promise<void> => this.onToggleHabit(item),
                  onLongPress: (): void => this.onLongPress(item.habit.ddlId)
                })
              }
            }, (item: HabitWithDailyStatus) => item.habit.id.toString() + "_" + item.doneCount)
          }
          .width('100%')
          .layoutWeight(1)
          .padding({ left: 16, right: 16, bottom: 96 })
        }
      }
    }
    .width('100%')
    .height('100%')
  }
}

// â€”â€” 6. å ä½ç»„ä»¶ (åç»­æ›¿æ¢) â€”â€”

@Component
struct PlaceholderHabitCircleProgress {
  @Prop progress: number;
  build() {
    Stack({ alignContent: Alignment.Center }) {
      Progress({ value: this.progress * 100, total: 100, type: ProgressType.Ring })
        .width(80).height(80)
        .color(Color.Blue)
        .style({ strokeWidth: 8 })
      Text(`${(this.progress * 100).toFixed(0)}%`)
        .fontSize(16)
    }
    .backgroundColor('#F0F0F0') // æ–¹ä¾¿è°ƒè¯•çœ‹åŒºåŸŸ
    .borderRadius(12)
  }
}

@Component
struct PlaceholderWeekRow {
  @Prop weekOverview: DayOverview[];
  @Prop selectedDate: Date;
  onSelectDate: (d: Date) => void = () => {};

  build() {
    Row({ space: 8 }) {
      ForEach(this.weekOverview, (day: DayOverview) => {
        Column() {
          Text(day.date.getDate().toString())
            .fontWeight(day.date.toDateString() === this.selectedDate.toDateString() ? FontWeight.Bold : FontWeight.Normal)
            .fontColor(day.date.toDateString() === this.selectedDate.toDateString() ? Color.Blue : Color.Black)
          Circle()
            .width(6).height(6)
            .fill(day.completedCount > 0 ? Color.Green : Color.Transparent)
        }
        .onClick(() => this.onSelectDate(day.date))
        .layoutWeight(1)
        .alignItems(HorizontalAlign.Center)
      })
    }
    .padding(8)
    .backgroundColor('#FAFAFA')
  }
}

@Component
struct PlaceholderHabitRow {
  @ObjectLink data: HabitWithDailyStatus; // éœ€è¦ Class æ‰èƒ½ ObjectLinkï¼Œè¿™é‡Œ interface æš‚æ—¶ä¼ å€¼æˆ–è€…æ”¹ä¸º Prop
  // ä¸ºç®€å•èµ·è§ï¼Œè¿™é‡Œç”¨ Prop æˆ–ç›´æ¥ä¼ å‚
  @Prop isSelected: boolean;
  @Prop canToggle: boolean;
  @Prop remainingText: string;
  onToggle: () => void = () => {};
  onLongPress: () => void = () => {};

  build() {
    Row() {
      if (this.isSelected) {
        Checkbox({ name: 'select', group: 'sel' }).select(true).margin({ right: 8 })
      }
      Column() {
        Text(this.data.habit.name).fontSize(16).fontWeight(FontWeight.Medium)
        Text(this.remainingText).fontSize(12).fontColor(Color.Gray)
      }
      .layoutWeight(1)
      .alignItems(HorizontalAlign.Start)

      Button(this.data.isCompleted ? "å·²å®Œæˆ" : "æ‰“å¡")
        .type(ButtonType.Normal)
        .fontSize(12)
        .height(30)
        .backgroundColor(this.data.isCompleted ? Color.Green : Color.Blue)
        .opacity(this.canToggle ? 1 : 0.5)
        .enabled(this.canToggle)
        .onClick(() => this.onToggle())
    }
    .width('100%')
    .padding(12)
    .backgroundColor(Color.White)
    .borderRadius(8)
    .gesture(
      LongPressGesture()
        .onAction(() => this.onLongPress())
    )
  }
}
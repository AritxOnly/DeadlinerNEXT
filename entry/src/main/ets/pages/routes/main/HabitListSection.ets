import { TopSafeContainer } from "../../components/TopSafeContainer"
import { HabitRepository } from '../../../common/repository/HabitRepository';
import { Habit, HabitGoalType, HabitPeriod, HabitRecordStatus, HabitStatus } from '../../../model/DDLModels';
import { HabitCircleProgress, WeekRow, HabitRow, DDLStatus, HabitWithDailyStatus, DayOverview } from '../../components/HabitComponents'
import { HabitListController } from "./HabitListController";
import { ChipGroup, ChipGroupItemOptions, ChipSize, promptAction } from '@kit.ArkUI'
import { VibrationUtils } from "../../../utils/VibrationUtils";
import { ConfettiController } from "../../components/confetti/ConfettiController";

const COMMON_RADIUS = 24;
const ITEM_HEIGHT = 56;

@Component
export struct HabitListSection {
  @Prop topAvoidHeight: number = 0;

  scroller: Scroller = new Scroller();
  confetti: ConfettiController = new ConfettiController();
  controller: HabitListController = new HabitListController();

  // â€”â€” 1. æ•°æ®æº (@State) â€”â€”
  @State selectedDate: Date = new Date();
  @State searchQuery: string = "";
  @State weekOverview: DayOverview[] = [];
  @State displayHabits: HabitWithDailyStatus[] = [];

  // å†…å­˜ç¼“å­˜
  private allHabitsCache: HabitWithDailyStatus[] = [];

  // äº¤äº’æ¨¡å¼çŠ¶æ€ï¼ˆå¯¹åº” selectionModeï¼‰
  @Link isSelectionMode: boolean;
  @State selectedDdlIds: Set<number> = new Set();

  private repo = HabitRepository.getInstance();

  // â€”â€” 2. ç”Ÿå‘½å‘¨æœŸ â€”â€”
  aboutToAppear() {
    this.refreshAll(this.selectedDate);

    if (this.controller) {
      this.bindController();
    }

    getContext(this).eventHub.on('sync_done', this.onSyncEvent);
  }

  aboutToDisappear() {
    getContext(this).eventHub.off('sync_done', this.onSyncEvent);
  }

  private onSyncEvent = () => {
    console.debug('HabitListSection received sync_done event');
    this.refreshAll(this.selectedDate);
  }

  private bindController() {
    this.controller.requestBatchComplete = (): Promise<void> => this.handleBatchComplete();
    this.controller.requestBatchArchive = (): Promise<void> => this.handleBatchArchive();
    this.controller.requestBatchDelete = (): Promise<void> => this.handleBatchDelete();
    this.controller.requestBatchEdit = (): void => this.handleBatchEdit();
    this.controller.requestExitSelection = (): void => this.exitSelectionMode();
  }

  // â€”â€” 3. ä¸šåŠ¡é€»è¾‘ â€”â€”

  async refreshAll(date: Date) {
    const allHabits = await this.repo.getAllHabits();

    // è®¡ç®—åˆ—è¡¨çŠ¶æ€
    const statusList = await Promise.all(allHabits.map(h => this.buildStatusForDate(h, date)));
    this.allHabitsCache = statusList;
    this.applyFilter();

    // è®¡ç®—å‘¨è§†å›¾
    this.calculateWeekOverview(date, allHabits);
  }

  private async buildStatusForDate(habit: Habit, date: Date): Promise<HabitWithDailyStatus> {
    const GeneratedDestructArray_1 = this.getPeriodBounds(habit.period, date);
    const start = GeneratedDestructArray_1[0];
    const end = GeneratedDestructArray_1[1];
    const queryStart = habit.goalType === HabitGoalType.TOTAL ? new Date(0) : start;
    const queryEnd = habit.goalType === HabitGoalType.TOTAL ? date : end;

    const records = await this.repo.getRecordsForHabitInRange(habit.id, queryStart, queryEnd);

    const done = records
      .filter(r => r.status === HabitRecordStatus.COMPLETED)
      .reduce((sum, r) => sum + r.count, 0);

    let target = Math.max(1, habit.timesPerPeriod);
    if (habit.goalType === HabitGoalType.TOTAL) {
      target = habit.totalTarget ? Math.max(1, habit.totalTarget) : Math.max(1, done);
    }

    return {
      habit: habit,
      doneCount: done,
      targetCount: target,
      isCompleted: habit.totalTarget ? done >= habit.totalTarget : done >= target
    };
  }

  private applyFilter() {
    if (!this.searchQuery || this.searchQuery.trim() === "") {
      this.displayHabits = this.allHabitsCache;
    } else {
      const lowerQ = this.searchQuery.toLowerCase();
      this.displayHabits = this.allHabitsCache.filter(it =>
      it.habit.name.toLowerCase().includes(lowerQ)
      );
    }
  }

  // æ—¥æœŸè¾…åŠ©é€»è¾‘
  private getPeriodBounds(period: HabitPeriod, date: Date): [Date, Date] {
    const d = new Date(date);
    d.setHours(0, 0, 0, 0);

    if (period === HabitPeriod.DAILY) {
      return [d, d];
    } else if (period === HabitPeriod.WEEKLY) {
      const day = d.getDay();
      const diff = d.getDate() - day + (day === 0 ? -6 : 1);
      const monday = new Date(d.setDate(diff));
      const sunday = new Date(monday);
      sunday.setDate(monday.getDate() + 6);
      return [monday, sunday];
    } else if (period === HabitPeriod.MONTHLY) {
      const firstDay = new Date(d.getFullYear(), d.getMonth(), 1);
      const lastDay = new Date(d.getFullYear(), d.getMonth() + 1, 0);
      return [firstDay, lastDay];
    }
    return [d, d];
  }

  private async calculateWeekOverview(centerDate: Date, allHabits: Habit[]) {
    const d = new Date(centerDate);
    const day = d.getDay();
    const diff = d.getDate() - day + (day === 0 ? -6 : 1);
    const monday = new Date(d.setDate(diff));

    const week: DayOverview[] = [];
    for (let i = 0; i < 7; i++) {
      const current = new Date(monday);
      current.setDate(monday.getDate() + i);

      // ç®€åŒ–è®¡ç®—ï¼šå®é™…é¡¹ç›®å¯èƒ½éœ€è¦ä¼˜åŒ–æ€§èƒ½
      const statuses = await Promise.all(allHabits.map(h => this.buildStatusForDate(h, current)));
      const completedCount = statuses.filter(s => s.isCompleted).length;
      const totalCount = allHabits.length;

      week.push({
        date: current,
        completedCount: completedCount,
        totalCount: totalCount,
        completionRatio: totalCount > 0 ? (completedCount / totalCount) : 0
      });
    }
    this.weekOverview = week;
  }

  // â€”â€” 4. äº¤äº’äº‹ä»¶ â€”â€”

  onDateSelected(date: Date) {
    this.selectedDate = date;
    this.refreshAll(date);
  }

  async onToggleHabit(item: HabitWithDailyStatus) {
    // åªæœ‰é€‰ä¸­çš„æ—¥æœŸä¸æ™šäºä»Šå¤©æ‰èƒ½æ‰“å¡
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const currentSel = new Date(this.selectedDate);
    currentSel.setHours(0, 0, 0, 0);

    if (currentSel.getTime() > today.getTime()) {
      return; // æœªæ¥æ—¥æœŸä¸å¯æ‰“å¡
    }

    if (this.isSelectionMode) {
      this.toggleSelection(item.habit.ddlId);
      return;
    }

    VibrationUtils.vibrateShort();

    const beforeRate = item.doneCount / item.targetCount;
    await this.repo.toggleRecord(item.habit.id, this.selectedDate);
    await this.refreshAll(this.selectedDate);

    // åº†ç¥æ£€æµ‹
    const afterItem = this.allHabitsCache.find(it => it.habit.id === item.habit.id);
    if (afterItem) {
      const afterRate = afterItem.doneCount / afterItem.targetCount;
      if (beforeRate < 1 && afterRate >= 1) {
        console.info("ğŸ‰ Habit Completed!");
        this.confetti.fire();
      }
    }
  }

  exitSelectionMode() {
    this.isSelectionMode = false;
    this.selectedDdlIds.clear();
  }

  async handleBatchComplete() {
    if (this.selectedDdlIds.size === 0) return;

    VibrationUtils.vibrateShort();
    // ç­›é€‰å‡ºé€‰ä¸­çš„ã€ä¸”å½“å¤©è¿˜ã€æœªå®Œæˆã€‘çš„ä¹ æƒ¯
    // æ³¨æ„ï¼šallHabitsCache é‡Œå­˜çš„æ˜¯ HabitWithDailyStatusï¼ŒåŒ…å« ddlId
    const targets = this.allHabitsCache.filter(item =>
    this.selectedDdlIds.has(item.habit.ddlId) && !item.isCompleted
    );

    if (targets.length === 0) {
      promptAction.showToast({ message: 'é€‰ä¸­çš„ä¹ æƒ¯å·²å…¨éƒ¨å®Œæˆ' });
      this.exitSelectionMode();
      return;
    }

    try {
      // å¹¶è¡Œæ‰§è¡Œæ’å…¥è®°å½•
      // æ³¨æ„ï¼šè¿™é‡Œç®€å•åœ°æ’å…¥ä¸€æ¡è®°å½•ã€‚å¦‚æœéœ€è¦ç²¾ç¡®æ§åˆ¶æ¬¡æ•°ï¼ˆæ¯”å¦‚ç›®æ ‡æ˜¯3æ¬¡ï¼Œç°åœ¨æ˜¯0æ¬¡ï¼Œæ˜¯å¦ç›´æ¥åŠ æ»¡ï¼Ÿï¼‰ï¼Œ
      // ç›®å‰é€»è¾‘æ˜¯ insertRecord é»˜è®¤ count=1ã€‚
      // å¦‚æœä½ çš„â€œæ‰¹é‡å®Œæˆâ€å®šä¹‰æ˜¯â€œç›´æ¥è®¾ä¸ºè¾¾æ ‡â€ï¼Œä½ éœ€è¦è®¡ç®—ç¼ºå¤šå°‘æ¬¡ã€‚
      // è¿™é‡Œç®€åŒ–ä¸ºï¼šç›´æ¥è¡¥é½åˆ°ç›®æ ‡æ¬¡æ•° (æˆ–è€…ç®€å•åœ°åŠ ä¸€æ¬¡ï¼Œè§†ä½ çš„ä¸šåŠ¡å®šä¹‰è€Œå®š)
      // å‡è®¾ä¸šåŠ¡å®šä¹‰ï¼šæ‰¹é‡æ‰“å¡ = ç»™é€‰ä¸­çš„æ¯ä¸€é¡¹åŠ ä¸€æ¬¡æ‰“å¡
      await Promise.all(targets.map(item => {
        return this.repo.insertRecord(item.habit.id, this.selectedDate, 1);
      }));

      promptAction.showToast({ message: `å·²æ‰“å¡ ${targets.length} ä¸ªä¹ æƒ¯` });
      this.refreshAll(this.selectedDate);
      this.exitSelectionMode();
    } catch (e) {
      console.error('Batch complete failed:', e);
      promptAction.showToast({ message: 'æ“ä½œå¤±è´¥' });
    }
  }

  async handleBatchDelete() {
    if (this.selectedDdlIds.size === 0) return;

    VibrationUtils.vibrateMedium();
    // å¼¹çª—ç¡®è®¤
    AlertDialog.show({
      title: 'åˆ é™¤ä¹ æƒ¯',
      message: `ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„ ${this.selectedDdlIds.size} ä¸ªä¹ æƒ¯å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚`,
      autoCancel: true, // ç‚¹å‡»é®ç½©å±‚æ˜¯å¦å…³é—­
      alignment: DialogAlignment.Bottom, // å¼¹çª—ä½ç½®
      offset: { dx: 0, dy: -20 }, // å¾®è°ƒä½ç½®
      gridCount: 4, // å¼¹çª—å®½åº¦å ç”¨æ …æ ¼æ•°
      backgroundBlurStyle: BlurStyle.Regular,
      primaryButton: {
        value: 'å–æ¶ˆ',
        fontColor: $r('app.color.brand'), // ä½ çš„ä¸»é¢˜è‰²
        action: () => {
          // ç‚¹å‡»å–æ¶ˆï¼Œä¸åšä»»ä½•äº‹ï¼Œæˆ–è€…å¯ä»¥é€€å‡ºé€‰æ‹©æ¨¡å¼
        }
      },
      secondaryButton: {
        value: 'åˆ é™¤',
        fontColor: Color.Red,
        action: async () => {
          // ç‚¹å‡»åˆ é™¤
          try {
            const idsToDelete = Array.from(this.selectedDdlIds);
            await Promise.all(idsToDelete.map(ddlId => this.repo.deleteHabitByDdlId(ddlId)));

            promptAction.showToast({ message: 'åˆ é™¤æˆåŠŸ' });
            this.refreshAll(this.selectedDate);
            this.exitSelectionMode();
            // é€šçŸ¥å…¨å±€åˆ·æ–°
            getContext(this).eventHub.emit('sync_done');
          } catch (e) {
            console.error('Batch delete failed:', e);
            promptAction.showToast({ message: 'åˆ é™¤å¤±è´¥' });
          }
        }
      }
    })
  }

  async handleBatchArchive() {
    if (this.selectedDdlIds.size === 0) return;

    try {
      const targets = this.allHabitsCache.filter(item => this.selectedDdlIds.has(item.habit.ddlId));

      await Promise.all(targets.map(item => {
        // æ›´æ–°çŠ¶æ€ä¸º ARCHIVED
        const updatedHabit = item.habit;
        updatedHabit.status = HabitStatus.ARCHIVED;
        return this.repo.updateHabit(updatedHabit);
      }));

      promptAction.showToast({ message: `å·²å½’æ¡£ ${targets.length} ä¸ªä¹ æƒ¯` });
      this.refreshAll(this.selectedDate);
      this.exitSelectionMode();
    } catch (e) {
      console.error('Batch archive failed:', e);
      promptAction.showToast({ message: 'å½’æ¡£å¤±è´¥' });
    }
  }

  handleBatchEdit() {
    if (this.selectedDdlIds.size === 0) {
      promptAction.showToast({ message: 'æœªé€‰ä¸­ä»»ä½•ä¹ æƒ¯' });
      return;
    }

    const ddlId: number = this.selectedDdlIds.values().next().value;

    const targetItem = this.allHabitsCache.find(it => it.habit.ddlId === ddlId);

    if (!targetItem) {
      promptAction.showToast({ message: 'æœªæ‰¾åˆ°ä¹ æƒ¯æ•°æ®' });
      return;
    }

    // 5. é€€å‡ºé€‰æ‹©æ¨¡å¼
    this.exitSelectionMode();

    // 6. å¡«å……æ•°æ®å¹¶æ‰“å¼€ç¼–è¾‘é¡µ
    this.prepareEditData(targetItem.habit);
  }

  private prepareEditData(habit: Habit) {
    // åŸºç¡€ä¿¡æ¯
    this.editingHabitId = habit.id;
    this.editingHabitName = habit.name;

    // å‘¨æœŸï¼šæšä¸¾ -> ç´¢å¼•
    // è¿™é‡Œçš„é¡ºåºå¿…é¡»ä¸ periodOptions æ•°ç»„ä¸€è‡´: [DAILY, WEEKLY, MONTHLY]
    const pMap = [HabitPeriod.DAILY, HabitPeriod.WEEKLY, HabitPeriod.MONTHLY];
    const pIndex = pMap.indexOf(habit.period);
    // å¦‚æœæ‰¾ä¸åˆ°(æ¯”å¦‚æ•°æ®é”™è¯¯)ï¼Œé»˜è®¤é€‰ç¬¬ä¸€ä¸ª(DAILY)
    this.editingPeriodIndex = [pIndex !== -1 ? pIndex : 0];

    // ç›®æ ‡ç±»å‹ï¼šæšä¸¾ -> ç´¢å¼•
    // è¿™é‡Œçš„é¡ºåºå¿…é¡»ä¸ goalTypeOptions æ•°ç»„ä¸€è‡´: [PER_PERIOD, TOTAL]
    const gMap = [HabitGoalType.PER_PERIOD, HabitGoalType.TOTAL];
    const gIndex = gMap.indexOf(habit.goalType);
    this.editingGoalTypeIndex = [gIndex !== -1 ? gIndex : 0];

    // æ•°å­—è½¬å­—ç¬¦ä¸²
    this.editingTimesPerPeriod = habit.timesPerPeriod.toString();
    this.editingTotalTarget = habit.totalTarget ? habit.totalTarget.toString() : "";

    // æ‰“å¼€ Sheet
    this.isEditSheetShow = true;
  }

  onLongPress(ddlId: number) {
    VibrationUtils.vibrateShort();
    this.isSelectionMode = true;
    this.toggleSelection(ddlId);
  }

  toggleSelection(ddlId: number) {
    if (this.selectedDdlIds.has(ddlId)) {
      this.selectedDdlIds.delete(ddlId);
      // å¦‚æœæ‰€æœ‰éƒ½å–æ¶ˆäº†ï¼Œå¯èƒ½éœ€è¦é€€å‡ºé€‰æ‹©æ¨¡å¼ï¼Œè§†éœ€æ±‚è€Œå®š
      if (this.selectedDdlIds.size === 0) {
        this.isSelectionMode = false;
      }
    } else {
      this.selectedDdlIds.add(ddlId);
    }
  }

  isSelected(ddlId: number): boolean {
    return this.selectedDdlIds.has(ddlId);
  }

  private getTodayCompletionRatio(): number {
    const todayOverview = this.weekOverview.find(
      d => d.date.toDateString() === this.selectedDate.toDateString()
    );
    return todayOverview ? todayOverview.completionRatio : 0;
  }

  // == ç¼–è¾‘è¡¨å• ==
  @State isEditSheetShow: boolean = false

  @State inputBgColor: ResourceColor = $r('app.color.background_tertiary')

  @State editingHabitId: number = -1;
  @State editingHabitName: string = '';

  @State editingPeriodIndex: number[] = [0];
  @State editingGoalTypeIndex: number[] = [0];

  @State editingTimesPerPeriod: string = '1';
  @State editingTotalTarget: string = '';

  private periodOptions: ChipGroupItemOptions[] = [
    { label: { text: "æ¯æ—¥" } },
    { label: { text: "æ¯å‘¨" } },
    { label: { text: "æ¯æœˆ" } }
  ];

  private goalTypeOptions: ChipGroupItemOptions[] = [
    { label: { text: "åšæŒ" } },
    { label: { text: "å®šé‡" } }
  ];

  // â€”â€” è¾…åŠ©å‡½æ•° â€”â€”
  private getGoalTypeFromIndex(index: number): HabitGoalType {
    const map = [HabitGoalType.PER_PERIOD, HabitGoalType.TOTAL];
    return map[index] || HabitGoalType.PER_PERIOD;
  }

  private getPeriodFromIndex(index: number): HabitPeriod {
    const map = [HabitPeriod.DAILY, HabitPeriod.WEEKLY, HabitPeriod.MONTHLY];
    return map[index] || HabitPeriod.DAILY;
  }

  @Builder
  habitEditSheet() {
    Column() {
      Column({ space: 16 }) {

        // 1. ä¹ æƒ¯åç§°
        TextInput({ placeholder: 'ä¹ æƒ¯åç§°', text: this.editingHabitName })
          .height(ITEM_HEIGHT)
          .fontSize(16)
          .backgroundColor(this.inputBgColor)
          .borderRadius(COMMON_RADIUS)
          .padding({ left: 16, right: 16 })
          .width('100%')
          .onChange((val) => {
            this.editingHabitName = val;
          })

        // 2. å‘¨æœŸé€‰æ‹© (ChipGroup)
        Column({ space: 8 }) {
          Text("é‡å¤å‘¨æœŸ")
            .fontSize(14)
            .fontColor(Color.Gray)
            .padding({ left: 4 })

          ChipGroup({
            items: this.periodOptions,
            itemStyle: {
              size: ChipSize.NORMAL,
              backgroundColor: this.inputBgColor,
              fontColor: Color.Gray,
              selectedBackgroundColor: $r('app.color.brand'),
              selectedFontColor: Color.White
            },
            selectedIndexes: this.editingPeriodIndex,
            onChange: (indexes: number[]) => {
              this.editingPeriodIndex = indexes;
            }
          })
        }
        .width('100%')
        .alignItems(HorizontalAlign.Start)

        // 3. ç›®æ ‡è®¾ç½® (Row å¸ƒå±€)
        Row({ space: 12 }) {
          // å·¦ä¾§ï¼šé¢‘ç‡æ¬¡æ•°
          Column({ space: 8 }) {
            Text("æ¯æ¬¡/é¢‘æ¬¡")
              .fontSize(14)
              .fontColor(Color.Gray)
              .padding({ left: 4 })

            TextInput({ placeholder: '1', text: this.editingTimesPerPeriod })
              .type(InputType.Number)
              .height(ITEM_HEIGHT)
              .fontSize(16)
              .backgroundColor(this.inputBgColor)
              .borderRadius(COMMON_RADIUS)
              .padding({ left: 16, right: 16 })
              .width('100%')
              .onChange((val) => {
                this.editingTimesPerPeriod = val;
              })
          }
          .layoutWeight(1)

          // å³ä¾§ï¼šç›®æ ‡ç±»å‹
          Column({ space: 8 }) {
            Text("ç›®æ ‡ç±»å‹")
              .fontSize(14)
              .fontColor(Color.Gray)
              .padding({ left: 4 })

            ChipGroup({
              items: this.goalTypeOptions,
              itemStyle: {
                size: ChipSize.NORMAL,
                backgroundColor: this.inputBgColor,
                fontColor: Color.Gray,
                selectedBackgroundColor: $r('app.color.brand'),
                selectedFontColor: Color.White
              },
              selectedIndexes: this.editingGoalTypeIndex,
              onChange: (indexes: number[]) => {
                this.editingGoalTypeIndex = indexes;
              }
            })
          }
          .layoutWeight(1)
        }
        .width('100%')
        .alignItems(VerticalAlign.Top)

        // 4. æ€»ç›®æ ‡è¾“å…¥æ¡† (åŠ¨æ€æ˜¾ç¤º)
        if (this.editingGoalTypeIndex.length > 0 &&
          this.getGoalTypeFromIndex(this.editingGoalTypeIndex[0]) === HabitGoalType.TOTAL) {
          Column({ space: 8 }) {
            Text("æ€»ç›®æ ‡æ•°é‡")
              .fontSize(14)
              .fontColor(Color.Gray)
              .padding({ left: 4 })

            TextInput({ placeholder: 'ä¾‹å¦‚ï¼š100 (é¡µ/æ¬¡)', text: this.editingTotalTarget })
              .type(InputType.Number)
              .height(ITEM_HEIGHT)
              .fontSize(16)
              .backgroundColor(this.inputBgColor)
              .borderRadius(COMMON_RADIUS)
              .padding({ left: 16, right: 16 })
              .width('100%')
              .onChange((val) => {
                this.editingTotalTarget = val;
              })
          }
          .width('100%')
        }

        Button('ä¿å­˜').onClick((event: ClickEvent) => {
          this.saveHabitEdit();
        })
          .width('100%')
          .backgroundColor($r('app.color.brand'))

        Blank().height(60)
      }
      .width('100%')
    }
    .width('100%')
    .padding({ left: 16, right: 16, top: 16 }) // ç¨å¾®å¢åŠ é¡¶éƒ¨padding
  }

  // â€”â€” ä¿å­˜ç¼–è¾‘é€»è¾‘ â€”â€”
  private async saveHabitEdit() {
    // 1. åŸºç¡€æ ¡éªŒ
    if (!this.editingHabitName.trim()) {
      promptAction.showToast({ message: 'è¯·è¾“å…¥ä¹ æƒ¯åç§°' });
      return;
    }

    const times = parseInt(this.editingTimesPerPeriod);
    if (isNaN(times) || times <= 0) {
      promptAction.showToast({ message: 'è¯·è¾“å…¥æœ‰æ•ˆçš„å•æ¬¡ç›®æ ‡' });
      return;
    }

    // 2. è·å–æšä¸¾å€¼
    // é˜²å¾¡æ€§ç¼–ç¨‹ï¼šç¡®ä¿æ•°ç»„ä¸ä¸ºç©º
    const pIndex = this.editingPeriodIndex.length > 0 ? this.editingPeriodIndex[0] : 0;
    const gIndex = this.editingGoalTypeIndex.length > 0 ? this.editingGoalTypeIndex[0] : 0;

    const newPeriod = this.getPeriodFromIndex(pIndex); // éœ€è¦ç¡®ä¿ç»„ä»¶å†…æœ‰è¿™ä¸ª helper
    const newGoalType = this.getGoalTypeFromIndex(gIndex); // éœ€è¦ç¡®ä¿ç»„ä»¶å†…æœ‰è¿™ä¸ª helper

    // 3. æ ¡éªŒæ€»ç›®æ ‡ (å¦‚æœæ˜¯ TOTAL ç±»å‹)
    let total: number | null = null;
    if (newGoalType === HabitGoalType.TOTAL) {
      total = parseInt(this.editingTotalTarget);
      if (isNaN(total) || total <= 0) {
        promptAction.showToast({ message: 'è¯·è¾“å…¥æœ‰æ•ˆçš„æ€»ç›®æ ‡' });
        return;
      }
    }

    try {
      // 4. è·å–åŸå§‹å¯¹è±¡å¹¶æ›´æ–°
      // æˆ‘ä»¬éœ€è¦å…ˆä»ç¼“å­˜æˆ–Repoé‡Œæ‹¿åˆ°å®Œæ•´çš„ Habit å¯¹è±¡ï¼Œå› ä¸º update éœ€è¦ id, ddlId, createdAt ç­‰å­—æ®µ
      // å‡è®¾æˆ‘ä»¬é€šè¿‡ editingHabitId èƒ½æ‰¾åˆ°å®ƒ
      const originalItem = this.allHabitsCache.find(it => it.habit.id === this.editingHabitId);

      if (!originalItem) {
        promptAction.showToast({ message: 'æœªæ‰¾åˆ°åŸå§‹ä¹ æƒ¯æ•°æ®' });
        return;
      }

      const originalHabit = originalItem.habit;

      // æ„å»ºæ›´æ–°åçš„å¯¹è±¡
      const updatedHabit: Habit = {
        id: originalHabit.id,
        ddlId: originalHabit.ddlId,
        name: this.editingHabitName,
        description: "",
        color: originalHabit.color,
        iconKey: originalHabit.iconKey,
        period: newPeriod,
        timesPerPeriod: times,
        goalType: newGoalType,
        totalTarget: total,
        createdAt: originalHabit.createdAt,
        updatedAt: new Date().toISOString(),
        status: originalHabit.status,
        sortOrder: originalHabit.sortOrder,
        alarmTime: originalHabit.alarmTime
      };

      // 5. æ‰§è¡Œæ•°æ®åº“æ›´æ–°
      await this.repo.updateHabit(updatedHabit);

      // (å¯é€‰) å¦‚æœä½ çš„ DDL è¡¨ä¹Ÿå­˜å‚¨äº† Name/Note ç”¨äºæœç´¢ï¼Œä¹Ÿéœ€è¦æ›´æ–° DDL è¡¨
      // æ¯”å¦‚: await DatabaseHelper.getInstance().updateDDLNameAndNote(updatedHabit.ddlId, updatedHabit.name, updatedHabit.description);

      // 6. æ”¶å°¾å·¥ä½œ
      promptAction.showToast({ message: 'ä¿®æ”¹æˆåŠŸ' });

      // å…³é—­ Sheet (å‡è®¾ä½ ç”¨ isEditSheetShow æ§åˆ¶)
      this.isEditSheetShow = false;

      // åˆ·æ–°åˆ—è¡¨
      await this.refreshAll(this.selectedDate);

      // é€šçŸ¥å…¨å±€ (å¦‚æœéœ€è¦)
      getContext(this).eventHub.emit('sync_done');

    } catch (e) {
      console.error(`Update habit failed: ${e}`);
      promptAction.showToast({ message: 'ä¿®æ”¹å¤±è´¥' });
    }
  }

  @State isRefreshing: boolean = false;

  build() {
    Column() {
      TopSafeContainer({ topAvoidHeight: this.topAvoidHeight, scrollable: false }) {
        Column() {
          // 1. é¡¶éƒ¨è¿›åº¦ (ä½¿ç”¨æ–°ç»„ä»¶)
          HabitCircleProgress({ progress: this.getTodayCompletionRatio() })
            .margin({ top: 12, bottom: 12 })

          // 2. æœ¬å‘¨æ—¥æœŸæ¨ªæ¡ (ä½¿ç”¨æ–°ç»„ä»¶)
          WeekRow({
            weekOverview: this.weekOverview,
            selectedDate: this.selectedDate,
            onSelectDate: (d: Date): void => this.onDateSelected(d)
          })
            .margin({ bottom: 8 })
            .width('100%')

          Refresh({
            refreshing: $$this.isRefreshing
          }) {
            List({ scroller: this.scroller, space: 10 }) {
              ForEach(this.displayHabits, (item: HabitWithDailyStatus) => {
                ListItem() {
                  // ä½¿ç”¨æ–°ç»„ä»¶ HabitRow
                  HabitRow({
                    data: item,
                    status: item.isCompleted ? DDLStatus.COMPLETED : DDLStatus.UNDERGO,
                    isSelected: this.isSelected(item.habit.ddlId),
                    canToggle: new Date(this.selectedDate).setHours(0, 0, 0, 0) <= new Date().setHours(0, 0, 0, 0),
                    remainingText: "",
                    onToggle: (): Promise<void> => this.onToggleHabit(item),
                    onLongPress: (): void => this.onLongPress(item.habit.ddlId)
                  })
                }
              }, (item: HabitWithDailyStatus) => {
                return `${item.habit.id}_${item.doneCount}_${item.habit.updatedAt}`;
              })
            }
            .width('100%')
            .height("100%")
            .layoutWeight(1)
            .padding({ left: 12, right: 12, bottom: 96 })
            .scrollBar(BarState.Off)
            .edgeEffect(EdgeEffect.Spring, { alwaysEnabled: true })
          }
          .onRefreshing(async () => {
            this.isRefreshing = true

            await this.refreshAll(this.selectedDate);
            this.isRefreshing = false;
          })
        }
      }
    }
    .width('100%')
    .height('100%')
    .bindSheet($$this.isEditSheetShow, this.habitEditSheet(), {
      height: SheetSize.FIT_CONTENT,
      dragBar: true,
      onDisappear: () => {
        this.isEditSheetShow = false;
        this.editingHabitId = -1;
        this.editingHabitName = '';
        this.editingPeriodIndex = [];
        this.editingGoalTypeIndex = [];
        this.editingTimesPerPeriod = '';
        this.editingTotalTarget = '';
      },
      blurStyle: BlurStyle.Regular,
      backgroundColor: Color.Transparent,
      title: {
        title: 'ç¼–è¾‘ä¹ æƒ¯',
        subtitle: 'ä¿®æ”¹ä¹ æƒ¯ä¿¡æ¯ã€‚'
      }
    })
    .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.BOTTOM])
  }
}
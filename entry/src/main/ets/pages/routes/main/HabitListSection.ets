import { TopSafeContainer } from "../../components/TopSafeContainer"
import { HabitRepository } from '../../../common/repository/HabitRepository';
import { Habit, HabitGoalType, HabitPeriod, HabitRecordStatus, HabitStatus } from '../../../model/DDLModels';
import { HabitCircleProgress, WeekRow, HabitRow, DDLStatus, HabitWithDailyStatus, DayOverview } from '../../components/HabitComponents'
import { HabitListController } from "./HabitListController";
import { ChipGroup, ChipGroupItemOptions, ChipSize, promptAction } from '@kit.ArkUI'
import { VibrationUtils } from "../../../utils/VibrationUtils";
import { ConfettiController } from "../../components/confetti/ConfettiController";
import { FloatUpModifier } from "../../../utils/animation/FloatUpModifier";
import { HabitEditSheet } from "./modify/HabitEditSheet";
import { HabitReminderDialog } from "../../components/HabitReminderDialog";
import { ReminderScheduler } from "../../../utils/notification/ReminderScheduler";

const COMMON_RADIUS = 24;
const ITEM_HEIGHT = 56;

@Component
export struct HabitListSection {
  @Prop topAvoidHeight: number = 0;

  scroller: Scroller = new Scroller();
  confetti: ConfettiController = new ConfettiController();
  controller: HabitListController = new HabitListController();

  // ‚Äî‚Äî 1. Êï∞ÊçÆÊ∫ê (@State) ‚Äî‚Äî
  @State selectedDate: Date = new Date();
  @State searchQuery: string = "";
  @State weekOverview: DayOverview[] = [];
  @State displayHabits: HabitWithDailyStatus[] = [];

  // ÂÜÖÂ≠òÁºìÂ≠ò
  private allHabitsCache: HabitWithDailyStatus[] = [];

  // ‰∫§‰∫íÊ®°ÂºèÁä∂ÊÄÅÔºàÂØπÂ∫î selectionModeÔºâ
  @Link isSelectionMode: boolean;
  @State selectedDdlIds: Set<number> = new Set();

  private repo = HabitRepository.getInstance();

  @State tempHabitName: string = "";
  @State tempIsEnabled: boolean = false;
  @State tempSelectedTime: Date = new Date();
  @State currentAlarmDdlId: number = -1;

  // ÂÆö‰πâ CustomDialogController
  alarmDialogController: CustomDialogController = new CustomDialogController({
    builder: HabitReminderDialog({
      habitName: this.tempHabitName,
      isEnabled: this.tempIsEnabled,
      selectedTime: this.tempSelectedTime,
      onConfirm: (enabled, timeStr): Promise<void> => this.saveAlarmSetting(enabled, timeStr)
    }),
    // ‰øÆÊîπÁÇπÔºöËÆæÁΩÆ‰∏∫Â±Ö‰∏≠
    alignment: DialogAlignment.Center,
    // Â±Ö‰∏≠Êó∂ÈÄöÂ∏∏‰∏çÈúÄË¶Å offsetÔºåÈô§Èùû‰Ω†ÊÉ≥ÂæÆË∞É
    offset: { dx: 0, dy: 0 },
    autoCancel: true,
    customStyle: true
  });

  // ‚Äî‚Äî 2. ÁîüÂëΩÂë®Êúü ‚Äî‚Äî
  aboutToAppear() {
    this.refreshAll(this.selectedDate);

    if (this.controller) {
      this.bindController();
    }

    getContext(this).eventHub.on('sync_done', this.onSyncEvent);
  }

  aboutToDisappear() {
    getContext(this).eventHub.off('sync_done', this.onSyncEvent);
  }

  private onSyncEvent = () => {
    console.debug('HabitListSection received sync_done event');
    this.refreshAll(this.selectedDate);
  }

  private bindController() {
    this.controller.requestBatchComplete = (): Promise<void> => this.handleBatchComplete();
    this.controller.requestBatchArchive = (): Promise<void> => this.handleBatchArchive();
    this.controller.requestBatchDelete = (): Promise<void> => this.handleBatchDelete();
    this.controller.requestBatchEdit = (): void => this.handleBatchEdit();
    this.controller.requestExitSelection = (): void => this.exitSelectionMode();
    this.controller.requestSetAlarm = (): Promise<void> => this.handleRequestSetAlarm();
    this.controller.loadData = (): Promise<void> => this.refreshAll(this.selectedDate);
  }

  /**
   * Â§ÑÁêÜËÆæÁΩÆÊèêÈÜíÁöÑËØ∑Ê±Ç
   * ÈÄªËæëÔºöÊ£ÄÊü•ÂΩìÂâçÊòØÂê¶ÈÄâ‰∏≠‰∫Ü„ÄêÂîØ‰∏Ä„ÄëÁöÑ‰∏Ä‰∏™‰π†ÊÉØÔºåÂ¶ÇÊûúÊòØÔºåÂàôÂºπÂá∫ËÆæÁΩÆÊ°Ü
   */
  async handleRequestSetAlarm() {
    // 1. Ê†°È™åÈÄâ‰∏≠Êï∞Èáè
    if (this.selectedDdlIds.size !== 1) {
      promptAction.showToast({ message: 'ËØ∑ÈÄâÊã©‰∏Ä‰∏™‰π†ÊÉØÊù•ËÆæÁΩÆÊèêÈÜí' });
      return;
    }

    const ddlId = Array.from(this.selectedDdlIds)[0];
    this.currentAlarmDdlId = ddlId;

    // 2. Ëé∑Âèñ‰π†ÊÉØÊï∞ÊçÆ
    const item = this.allHabitsCache.find(it => it.habit.ddlId === ddlId);
    if (!item) return;
    const habit = item.habit;

    // 3. ÂáÜÂ§áÂºπÁ™óÊï∞ÊçÆ (ÂØπÂ∫î Android ‰∏≠ÁöÑ try-catch Ëß£ÊûêÈÄªËæë)
    this.tempHabitName = habit.name;

    if (habit.alarmTime && habit.alarmTime.length > 0) {
      this.tempIsEnabled = true;
      // Ëß£Êûê "HH:mm"
      const parts = habit.alarmTime.split(':');
      const d = new Date();
      d.setHours(parseInt(parts[0]), parseInt(parts[1]));
      this.tempSelectedTime = d;
    } else {
      this.tempIsEnabled = false;
      // ÈªòËÆ§Êó∂Èó¥ 20:00
      const d = new Date();
      d.setHours(20, 0);
      this.tempSelectedTime = d;
    }

    // 4. ÊâìÂºÄÂºπÁ™ó
    this.alarmDialogController.open();

    // 5. ÂèØÈÄâÔºöÈÄÄÂá∫ÈÄâÊã©Ê®°Âºè (Ê†πÊçÆ‰∫§‰∫íËÆæËÆ°ÂÜ≥ÂÆöÔºåAndroid ‰ª£Á†ÅÊú™ÈÄÄÂá∫ÔºåËøôÈáåÂª∫ËÆÆ‰øùÁïôÈÄâÊã©Áä∂ÊÄÅÊàñÈÄÄÂá∫ÂùáÂèØ)
    // this.exitSelectionMode();
  }

  /**
   * ‰øùÂ≠òÊèêÈÜíËÆæÁΩÆ (ÂØπÂ∫î Android ÁöÑ onPositiveButton)
   */
  async saveAlarmSetting(enabled: boolean, timeStr: string) {
    if (this.currentAlarmDdlId === -1) return;

    try {
      // 1. ‰ªéÂ∫ì‰∏≠ÈáçÊñ∞Ëé∑ÂèñÊúÄÊñ∞ÂØπË±° (Èò≤Ê≠¢Âπ∂Âèë‰øÆÊîπ)
      const habitRaw = await this.repo.getHabitByDdlId(this.currentAlarmDdlId);
      if (!habitRaw) return;

      // 2. Êõ¥Êñ∞ÂØπË±°
      // Â¶ÇÊûú enabled ‰∏∫ trueÔºå‰øùÂ≠ò timeStr (‰æãÂ¶Ç "20:00")ÔºåÂê¶Âàô‰∏∫ null
      const updatedHabit = habitRaw; // Ê≥®ÊÑèÔºöÁõ¥Êé•‰øÆÊîπÂºïÁî®Êàñ clone
      updatedHabit.alarmTime = enabled ? timeStr : null; // ArkTS ‰∏≠Â¶ÇÊûúÁ±ªÂûãÂÆö‰πâÊòØ string | null

      await this.repo.updateHabit(updatedHabit);

      // 3. Ëß¶ÂèëË∞ÉÂ∫¶Âô®Âà∑Êñ∞
      const allHabits = await this.repo.getAllHabits();
      await ReminderScheduler.refreshHabits(allHabits);

      // 4. ÁïåÈù¢ÂèçÈ¶à
      promptAction.showToast({ message: enabled ? `Â∑≤ËÆæÁΩÆÊèêÈÜí: ${timeStr}` : 'ÊèêÈÜíÂ∑≤ÂÖ≥Èó≠' });

      // Âà∑Êñ∞ÂàóË°®ÊòæÁ§∫ÔºàËôΩÁÑ∂ alarmTime ÂèØËÉΩ‰∏çÊòæÁ§∫Âú®ÂàóË°®‰∏äÔºå‰ΩÜ‰øùÊåÅÊï∞ÊçÆ‰∏ÄËá¥ÊÄßÔºâ
      await this.refreshAll(this.selectedDate);

      // ÈÄÄÂá∫ÈÄâÊã©Ê®°Âºè
      this.exitSelectionMode();

    } catch (e) {
      console.error('Set alarm failed:', e);
      promptAction.showToast({ message: 'ËÆæÁΩÆÂ§±Ë¥•' });
    }
  }

  @State isFirstLoad: boolean = true;

  async refreshAll(date: Date) {
    const allHabitsRaw = await this.repo.getAllHabits();
    const allHabits = allHabitsRaw.filter(h => h.status !== HabitStatus.ARCHIVED);

    // ËÆ°ÁÆóÂàóË°®Áä∂ÊÄÅ
    const statusList = await Promise.all(allHabits.map(h => this.buildStatusForDate(h, date)));
    this.allHabitsCache = statusList;
    this.applyFilter();

    // ËÆ°ÁÆóÂë®ËßÜÂõæ
    this.calculateWeekOverview(date, allHabits);

    if (this.isFirstLoad) {
      setTimeout(() => {
        this.isFirstLoad = false;
      }, 750)
    }
  }

  private async buildStatusForDate(habit: Habit, date: Date): Promise<HabitWithDailyStatus> {
    const GeneratedDestructArray_1 = this.getPeriodBounds(habit.period, date);
    const start = GeneratedDestructArray_1[0];
    const end = GeneratedDestructArray_1[1];
    const queryStart = habit.goalType === HabitGoalType.TOTAL ? new Date(0) : start;
    const queryEnd = habit.goalType === HabitGoalType.TOTAL ? date : end;

    const records = await this.repo.getRecordsForHabitInRange(habit.id, queryStart, queryEnd);

    const done = records
      .filter(r => r.status === HabitRecordStatus.COMPLETED)
      .reduce((sum, r) => sum + r.count, 0);

    let target = Math.max(1, habit.timesPerPeriod);
    if (habit.goalType === HabitGoalType.TOTAL) {
      target = habit.totalTarget ? Math.max(1, habit.totalTarget) : Math.max(1, done);
    }

    return {
      habit: habit,
      doneCount: done,
      targetCount: target,
      isCompleted: habit.totalTarget ? done >= habit.totalTarget : done >= target
    };
  }

  private applyFilter() {
    if (!this.searchQuery || this.searchQuery.trim() === "") {
      this.displayHabits = this.allHabitsCache;
    } else {
      const lowerQ = this.searchQuery.toLowerCase();
      this.displayHabits = this.allHabitsCache.filter(it =>
      it.habit.name.toLowerCase().includes(lowerQ)
      );
    }
  }

  // Êó•ÊúüËæÖÂä©ÈÄªËæë
  private getPeriodBounds(period: HabitPeriod, date: Date): [Date, Date] {
    const d = new Date(date);
    d.setHours(0, 0, 0, 0);

    if (period === HabitPeriod.DAILY) {
      return [d, d];
    } else if (period === HabitPeriod.WEEKLY) {
      const day = d.getDay();
      const diff = d.getDate() - day + (day === 0 ? -6 : 1);
      const monday = new Date(d.setDate(diff));
      const sunday = new Date(monday);
      sunday.setDate(monday.getDate() + 6);
      return [monday, sunday];
    } else if (period === HabitPeriod.MONTHLY) {
      const firstDay = new Date(d.getFullYear(), d.getMonth(), 1);
      const lastDay = new Date(d.getFullYear(), d.getMonth() + 1, 0);
      return [firstDay, lastDay];
    }
    return [d, d];
  }

  private async calculateWeekOverview(centerDate: Date, allHabits: Habit[]) {
    const d = new Date(centerDate);
    const day = d.getDay();
    const diff = d.getDate() - day + (day === 0 ? -6 : 1);
    const monday = new Date(d.setDate(diff));

    const week: DayOverview[] = [];
    for (let i = 0; i < 7; i++) {
      const current = new Date(monday);
      current.setDate(monday.getDate() + i);

      // ÁÆÄÂåñËÆ°ÁÆóÔºöÂÆûÈôÖÈ°πÁõÆÂèØËÉΩÈúÄË¶Å‰ºòÂåñÊÄßËÉΩ
      const statuses = await Promise.all(allHabits.map(h => this.buildStatusForDate(h, current)));
      const completedCount = statuses.filter(s => s.isCompleted).length;
      const totalCount = allHabits.length;

      week.push({
        date: current,
        completedCount: completedCount,
        totalCount: totalCount,
        completionRatio: totalCount > 0 ? (completedCount / totalCount) : 0
      });
    }
    this.weekOverview = week;
  }

  // ‚Äî‚Äî 4. ‰∫§‰∫í‰∫ã‰ª∂ ‚Äî‚Äî

  onDateSelected(date: Date) {
    this.selectedDate = date;
    this.refreshAll(date);
  }

  async onToggleHabit(item: HabitWithDailyStatus) {
    // Âè™ÊúâÈÄâ‰∏≠ÁöÑÊó•Êúü‰∏çÊôö‰∫é‰ªäÂ§©ÊâçËÉΩÊâìÂç°
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const currentSel = new Date(this.selectedDate);
    currentSel.setHours(0, 0, 0, 0);

    if (currentSel.getTime() > today.getTime()) {
      return; // Êú™Êù•Êó•Êúü‰∏çÂèØÊâìÂç°
    }

    if (this.isSelectionMode) {
      this.toggleSelection(item.habit.ddlId);
      return;
    }

    VibrationUtils.vibrateShort();

    const beforeRate = item.doneCount / item.targetCount;
    await this.repo.toggleRecord(item.habit.id, this.selectedDate);
    await this.refreshAll(this.selectedDate);

    // Â∫ÜÁ•ùÊ£ÄÊµã
    const afterItem = this.allHabitsCache.find(it => it.habit.id === item.habit.id);
    if (afterItem) {
      const afterRate = afterItem.doneCount / afterItem.targetCount;
      if (beforeRate < 1 && afterRate >= 1) {
        console.info("üéâ Habit Completed!");
        this.confetti.fire();
      }
    }
  }

  exitSelectionMode() {
    this.isSelectionMode = false;
    this.selectedDdlIds.clear();
  }

  async handleBatchComplete() {
    if (this.selectedDdlIds.size === 0) return;

    VibrationUtils.vibrateShort();
    // Á≠õÈÄâÂá∫ÈÄâ‰∏≠ÁöÑ„ÄÅ‰∏îÂΩìÂ§©Ëøò„ÄêÊú™ÂÆåÊàê„ÄëÁöÑ‰π†ÊÉØ
    // Ê≥®ÊÑèÔºöallHabitsCache ÈáåÂ≠òÁöÑÊòØ HabitWithDailyStatusÔºåÂåÖÂê´ ddlId
    const targets = this.allHabitsCache.filter(item =>
    this.selectedDdlIds.has(item.habit.ddlId) && !item.isCompleted
    );

    if (targets.length === 0) {
      promptAction.showToast({ message: 'ÈÄâ‰∏≠ÁöÑ‰π†ÊÉØÂ∑≤ÂÖ®ÈÉ®ÂÆåÊàê' });
      this.exitSelectionMode();
      return;
    }

    try {
      // Âπ∂Ë°åÊâßË°åÊèíÂÖ•ËÆ∞ÂΩï
      // Ê≥®ÊÑèÔºöËøôÈáåÁÆÄÂçïÂú∞ÊèíÂÖ•‰∏ÄÊù°ËÆ∞ÂΩï„ÄÇÂ¶ÇÊûúÈúÄË¶ÅÁ≤æÁ°ÆÊéßÂà∂Ê¨°Êï∞ÔºàÊØîÂ¶ÇÁõÆÊ†áÊòØ3Ê¨°ÔºåÁé∞Âú®ÊòØ0Ê¨°ÔºåÊòØÂê¶Áõ¥Êé•Âä†Êª°ÔºüÔºâÔºå
      // ÁõÆÂâçÈÄªËæëÊòØ insertRecord ÈªòËÆ§ count=1„ÄÇ
      // Â¶ÇÊûú‰Ω†ÁöÑ‚ÄúÊâπÈáèÂÆåÊàê‚ÄùÂÆö‰πâÊòØ‚ÄúÁõ¥Êé•ËÆæ‰∏∫ËææÊ†á‚ÄùÔºå‰Ω†ÈúÄË¶ÅËÆ°ÁÆóÁº∫Â§öÂ∞ëÊ¨°„ÄÇ
      // ËøôÈáåÁÆÄÂåñ‰∏∫ÔºöÁõ¥Êé•Ë°•ÈΩêÂà∞ÁõÆÊ†áÊ¨°Êï∞ (ÊàñËÄÖÁÆÄÂçïÂú∞Âä†‰∏ÄÊ¨°ÔºåËßÜ‰Ω†ÁöÑ‰∏öÂä°ÂÆö‰πâËÄåÂÆö)
      // ÂÅáËÆæ‰∏öÂä°ÂÆö‰πâÔºöÊâπÈáèÊâìÂç° = ÁªôÈÄâ‰∏≠ÁöÑÊØè‰∏ÄÈ°πÂä†‰∏ÄÊ¨°ÊâìÂç°
      await Promise.all(targets.map(item => {
        return this.repo.insertRecord(item.habit.id, this.selectedDate, 1);
      }));

      promptAction.showToast({ message: `Â∑≤ÊâìÂç° ${targets.length} ‰∏™‰π†ÊÉØ` });
      this.refreshAll(this.selectedDate);
      this.exitSelectionMode();
    } catch (e) {
      console.error('Batch complete failed:', e);
      promptAction.showToast({ message: 'Êìç‰ΩúÂ§±Ë¥•' });
    }
  }

  async handleBatchDelete() {
    if (this.selectedDdlIds.size === 0) return;

    VibrationUtils.vibrateMedium();
    // ÂºπÁ™óÁ°ÆËÆ§
    AlertDialog.show({
      title: 'Âà†Èô§‰π†ÊÉØ',
      message: `Á°ÆÂÆöË¶ÅÂà†Èô§ÈÄâ‰∏≠ÁöÑ ${this.selectedDdlIds.size} ‰∏™‰π†ÊÉØÂêóÔºüÊ≠§Êìç‰Ωú‰∏çÂèØÊÅ¢Â§ç„ÄÇ`,
      autoCancel: true, // ÁÇπÂáªÈÅÆÁΩ©Â±ÇÊòØÂê¶ÂÖ≥Èó≠
      alignment: DialogAlignment.Bottom, // ÂºπÁ™ó‰ΩçÁΩÆ
      offset: { dx: 0, dy: -20 }, // ÂæÆË∞É‰ΩçÁΩÆ
      gridCount: 4, // ÂºπÁ™óÂÆΩÂ∫¶Âç†Áî®Ê†ÖÊ†ºÊï∞
      backgroundBlurStyle: BlurStyle.Regular,
      primaryButton: {
        value: 'ÂèñÊ∂à',
        fontColor: $r('app.color.brand'), // ‰Ω†ÁöÑ‰∏ªÈ¢òËâ≤
        action: () => {
          // ÁÇπÂáªÂèñÊ∂àÔºå‰∏çÂÅö‰ªª‰Ωï‰∫ãÔºåÊàñËÄÖÂèØ‰ª•ÈÄÄÂá∫ÈÄâÊã©Ê®°Âºè
        }
      },
      secondaryButton: {
        value: 'Âà†Èô§',
        fontColor: Color.Red,
        action: async () => {
          // ÁÇπÂáªÂà†Èô§
          try {
            const idsToDelete = Array.from(this.selectedDdlIds);
            await Promise.all(idsToDelete.map(ddlId => this.repo.deleteHabitByDdlId(ddlId)));

            promptAction.showToast({ message: 'Âà†Èô§ÊàêÂäü' });
            this.refreshAll(this.selectedDate);
            this.exitSelectionMode();
            // ÈÄöÁü•ÂÖ®Â±ÄÂà∑Êñ∞
            getContext(this).eventHub.emit('sync_done');
          } catch (e) {
            console.error('Batch delete failed:', e);
            promptAction.showToast({ message: 'Âà†Èô§Â§±Ë¥•' });
          }
        }
      }
    })
  }

  async handleBatchArchive() {
    if (this.selectedDdlIds.size === 0) return;

    try {
      const targets = this.allHabitsCache.filter(item => this.selectedDdlIds.has(item.habit.ddlId));

      await Promise.all(targets.map(item => {
        // Êõ¥Êñ∞Áä∂ÊÄÅ‰∏∫ ARCHIVED
        const updatedHabit = item.habit;
        updatedHabit.status = HabitStatus.ARCHIVED;
        return this.repo.updateHabit(updatedHabit);
      }));

      promptAction.showToast({ message: `Â∑≤ÂΩíÊ°£ ${targets.length} ‰∏™‰π†ÊÉØ` });
      this.refreshAll(this.selectedDate);
      this.exitSelectionMode();
    } catch (e) {
      console.error('Batch archive failed:', e);
      promptAction.showToast({ message: 'ÂΩíÊ°£Â§±Ë¥•' });
    }
  }

  handleBatchEdit() {
    if (this.selectedDdlIds.size === 0) {
      promptAction.showToast({ message: 'Êú™ÈÄâ‰∏≠‰ªª‰Ωï‰π†ÊÉØ' });
      return;
    }

    const ddlId: number = this.selectedDdlIds.values().next().value;

    const targetItem = this.allHabitsCache.find(it => it.habit.ddlId === ddlId);

    if (!targetItem) {
      promptAction.showToast({ message: 'Êú™ÊâæÂà∞‰π†ÊÉØÊï∞ÊçÆ' });
      return;
    }

    // 5. ÈÄÄÂá∫ÈÄâÊã©Ê®°Âºè
    this.exitSelectionMode();

    // 6. Â°´ÂÖÖÊï∞ÊçÆÂπ∂ÊâìÂºÄÁºñËæëÈ°µ
    this.currentEditingHabit = targetItem.habit;
    this.isEditSheetShow = true;
  }

  onLongPress(ddlId: number) {
    VibrationUtils.vibrateShort();
    this.isSelectionMode = true;
    this.toggleSelection(ddlId);
  }

  toggleSelection(ddlId: number) {
    if (this.selectedDdlIds.has(ddlId)) {
      this.selectedDdlIds.delete(ddlId);
      // Â¶ÇÊûúÊâÄÊúâÈÉΩÂèñÊ∂à‰∫ÜÔºåÂèØËÉΩÈúÄË¶ÅÈÄÄÂá∫ÈÄâÊã©Ê®°ÂºèÔºåËßÜÈúÄÊ±ÇËÄåÂÆö
      if (this.selectedDdlIds.size === 0) {
        this.isSelectionMode = false;
      }
    } else {
      this.selectedDdlIds.add(ddlId);
    }
  }

  isSelected(ddlId: number): boolean {
    return this.selectedDdlIds.has(ddlId);
  }

  private getTodayCompletionRatio(): number {
    const todayOverview = this.weekOverview.find(
      d => d.date.toDateString() === this.selectedDate.toDateString()
    );
    return todayOverview ? todayOverview.completionRatio : 0;
  }

  // == ÁºñËæëË°®Âçï ==
  @State isEditSheetShow: boolean = false
  @State currentEditingHabit: Habit | undefined = undefined;

  // ‚Äî‚Äî ËæÖÂä©ÂáΩÊï∞ ‚Äî‚Äî
  private getGoalTypeFromIndex(index: number): HabitGoalType {
    const map = [HabitGoalType.PER_PERIOD, HabitGoalType.TOTAL];
    return map[index] || HabitGoalType.PER_PERIOD;
  }

  private getPeriodFromIndex(index: number): HabitPeriod {
    const map = [HabitPeriod.DAILY, HabitPeriod.WEEKLY, HabitPeriod.MONTHLY];
    return map[index] || HabitPeriod.DAILY;
  }

  @Builder
  habitEditSheet() {
    HabitEditSheet({
      isShow: $isEditSheetShow,
      editingHabit: this.currentEditingHabit,
      onSave: (habit): Promise<void> => this.handleSaveHabit(habit)
    })
  }

  async handleSaveHabit(updatedHabit: Habit) {
    // ÊâßË°åÊï∞ÊçÆÂ∫ìÊõ¥Êñ∞
    await this.repo.updateHabit(updatedHabit);
    // Âà∑Êñ∞ÂàóË°®
    await this.refreshAll(this.selectedDate);
    // ÂÖ®Â±ÄÈÄöÁü•
    getContext(this).eventHub.emit('sync_done');
  }

  @State isRefreshing: boolean = false;

  build() {
    Column() {
      TopSafeContainer({ topAvoidHeight: this.topAvoidHeight, scrollable: false }) {
        Column() {
          // 1. È°∂ÈÉ®ËøõÂ∫¶ (‰ΩøÁî®Êñ∞ÁªÑ‰ª∂)
          HabitCircleProgress({ progress: this.getTodayCompletionRatio() })
            .margin({ top: 12, bottom: 12 })
            .align(Alignment.Center)
            .attributeModifier(new FloatUpModifier(0, 15, this.isFirstLoad))

          // 2. Êú¨Âë®Êó•ÊúüÊ®™Êù° (‰ΩøÁî®Êñ∞ÁªÑ‰ª∂)
          WeekRow({
            weekOverview: this.weekOverview,
            selectedDate: this.selectedDate,
            onSelectDate: (d: Date): void => this.onDateSelected(d)
          })
            .margin({ bottom: 8 })
            .align(Alignment.Center)
            .attributeModifier(new FloatUpModifier(0, 15, this.isFirstLoad))

          Refresh({
            refreshing: $$this.isRefreshing
          }) {
            List({ scroller: this.scroller, space: 10 }) {
              ForEach(this.displayHabits, (item: HabitWithDailyStatus, index: number) => {
                ListItem() {
                  // ‰ΩøÁî®Êñ∞ÁªÑ‰ª∂ HabitRow
                  HabitRow({
                    data: item,
                    status: item.isCompleted ? DDLStatus.COMPLETED : DDLStatus.UNDERGO,
                    isSelected: this.isSelected(item.habit.ddlId),
                    canToggle: new Date(this.selectedDate).setHours(0, 0, 0, 0) <= new Date().setHours(0, 0, 0, 0),
                    remainingText: "",
                    onToggle: (): Promise<void> => this.onToggleHabit(item),
                    onLongPress: (): void => this.onLongPress(item.habit.ddlId)
                  })
                }
                .attributeModifier(new FloatUpModifier(index + 1, 15, this.isFirstLoad))
              }, (item: HabitWithDailyStatus) => {
                return `${item.habit.id}_${item.doneCount}_${item.habit.updatedAt}`;
              })

              ListItem() {
                Column() {
                  Blank().height(140)
                }
              }
            }
            .width('100%')
            .height('100%')
            .layoutWeight(1)
            .padding({ left: 12, right: 12 })
            .scrollBar(BarState.Off)
            .edgeEffect(EdgeEffect.Spring, { alwaysEnabled: true })
          }
          .onRefreshing(async () => {
            this.isRefreshing = true

            await this.refreshAll(this.selectedDate);
            this.isRefreshing = false;
          })
          .layoutWeight(1)
          .width('100%')
        }
        .height('100%')
        .width('100%')
        .layoutWeight(1)
      }
    }
    .width('100%')
    .height('100%')
    .bindSheet($$this.isEditSheetShow, this.habitEditSheet(), {
      height: SheetSize.FIT_CONTENT,
      dragBar: true,
      onDisappear: () => {
        this.isEditSheetShow = false;
        this.currentEditingHabit = undefined;
      },
      blurStyle: BlurStyle.Regular,
      backgroundColor: Color.Transparent,
      title: {
        title: 'ÁºñËæë‰π†ÊÉØ',
        subtitle: '‰øÆÊîπ‰π†ÊÉØ‰ø°ÊÅØ„ÄÇ'
      }
    })
    .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.BOTTOM])
  }
}
import { DDLStatus } from "../../../model/DDLStatus";
import { DDLItemCardSwipeable } from "../../components/TaskItemCard";
import { LengthMetrics, promptAction } from "@kit.ArkUI";
import { DDLItem, DeadlineType } from "../../../model/DDLModels";
import { TaskRepository } from "../../../common/repository/TaskRepository";
import { VibrationUtils } from "../../../utils/VibrationUtils";
import { TopSafeContainer } from "../../components/TopSafeContainer";
import { TaskListController } from "./TaskListController"
import { ConfettiController } from "../../components/confetti/ConfettiController";
import { TimeInputButton } from "../../components/TimeInputButton";
import { SettingsConstants as C } from "../../../common/local/SettingsConstants"

const COMMON_RADIUS = 24;
const ITEM_HEIGHT = 56;

interface TaskUIModel {
  title: string;
  remainingTimeAlt: string;
  note: string;
  progress: number;
  isStarred: boolean;
  status: DDLStatus;
  dbId: number;
}

@Component
export struct TaskListSection {
  scroller: Scroller = new Scroller();

  @State taskList: Array<TaskUIModel> = [];
  @State isRefreshing: boolean = false; // æ§åˆ¶ä¸‹æ‹‰åˆ·æ–°çŠ¶æ€

  @State isLoading: boolean = true;
  @Prop topAvoidHeight: number = 0;

  // å¤šé€‰æ¨¡å¼
  @Link isSelectionMode: boolean;
  @Require controller: TaskListController = new TaskListController();
  @State selectedIds: number[] = [];

  @Prop confetti: ConfettiController;

  @State isEditSheetShow: boolean = false;
  @State editingTask: DDLItem | null = null; // æš‚å­˜æ­£åœ¨ç¼–è¾‘çš„å®Œæ•´å¯¹è±¡
  @State editingTitle: string = "";          // ç»‘å®šè¾“å…¥æ¡†
  @State editingNote: string = "";           // ç»‘å®šè¾“å…¥æ¡†

  @State editingStartTime: Date = new Date();
  @State editingEndTime: Date = new Date();

  @State inputBgColor: ResourceColor = $r('app.color.background_tertiary');

  private repo = TaskRepository.getInstance();

  @StorageLink(C.KEY_PROGRESS_DIRECTION) @Watch('loadData') progressDir: boolean = false;

  async aboutToAppear() {
    this.bindController();

    await this.loadData();
    // ç›‘å¬åŒæ­¥å®Œæˆäº‹ä»¶ï¼Œè‡ªåŠ¨åˆ·æ–°
    getContext(this).eventHub.on('sync_done', () => {
      console.info('[Event] Received sync_done event, reloading...');
      this.loadData();
    });

    this.repo.syncNow().catch((e: Error) => console.error(e.message));
  }

  aboutToDisappear(): void {
    getContext(this).eventHub.off('sync_done');
  }

  // ç»‘å®šé€»è¾‘åˆ° Controller
  private bindController() {
    this.controller.requestBatchComplete = (): Promise<void> => this.handleBatchComplete();
    this.controller.requestBatchArchive = (): Promise<void> => this.handleBatchArchive();
    this.controller.requestBatchDelete = (): void => this.handleBatchDelete();
    this.controller.requestBatchEdit = (): Promise<void> => this.handleBatchEdit();
    this.controller.requestExitSelection = (): void => this.exitSelectionMode();
  }

  // åŠ è½½æ•°æ®ï¼šè¿‡æ»¤ + æ’åº + æ˜ å°„
  async loadData() {
    try {
      this.isLoading = true;

      const dbItems = await this.repo.getDDLsByType(DeadlineType.TASK);

      const now = new Date().getTime();

      // 2. é¢„å¤„ç†ï¼šè¿‡æ»¤ & æ’åº
      const processedItems = dbItems
        .filter((item) => {
          // è¿‡æ»¤æ¡ä»¶ï¼šæœªå½’æ¡£ (isArchived=false) ä¸” æœªåˆ é™¤ (deleted=false)
          // æ³¨æ„ï¼šgetAllDDLs SQLå±‚å¯èƒ½å·²ç»è¿‡æ»¤äº† deletedï¼Œä½†è¿™é‡ŒåŒé‡ä¿éšœ
          return !item.isArchived && !item.deleted && item.type !== DeadlineType.HABIT
        })
        .sort((a, b) => {
          if (a.isCompleted && !b.isCompleted) return 1;  // aå®Œæˆï¼Œbæœªå®Œæˆ -> aæ”¾åé¢
          if (!a.isCompleted && b.isCompleted) return -1; // aæœªå®Œæˆï¼Œbå®Œæˆ -> aæ”¾å‰é¢

          // é€»è¾‘Bï¼šçŠ¶æ€ç›¸åŒæ—¶ï¼ŒæŒ‰æˆªæ­¢æ—¶é—´æ’åºï¼ˆè¶Šæ—©è¶Šé å‰ï¼‰
          const timeA = new Date(a.endTime).getTime();
          const timeB = new Date(b.endTime).getTime();
          return timeA - timeB;
        });

      // 3. æ˜ å°„ä¸º UI æ¨¡å‹
      this.taskList = processedItems.map((item) => {
        return this.mapToUI(item, now);
      });

      console.info(`[TaskList] Loaded ${this.taskList.length} items.`);
    } catch (e) {
      console.error(`[TaskList] Load data failed: ${e}`);
    } finally {
      // æ— è®ºæˆåŠŸå¤±è´¥ï¼Œéƒ½è¦å…³é—­åˆ·æ–°åŠ¨ç”»
      this.isRefreshing = false;
      this.isLoading = false;
    }
  }

  // æ ¸å¿ƒé€»è¾‘ï¼šæ•°æ®æ˜ å°„ (DB Model -> UI Model)
  private mapToUI(item: DDLItem, now: number): TaskUIModel {
    // ç®€å•çš„æ—¥æœŸè§£æå®¹é”™
    const parseDate = (str: string): number => {
      const d = new Date(str);
      return isNaN(d.getTime()) ? 0 : d.getTime();
    };

    const start = parseDate(item.startTime);
    const end = parseDate(item.endTime);

    // 1. è®¡ç®—çŠ¶æ€
    let status = DDLStatus.UNDERGO;
    if (item.isCompleted) {
      status = DDLStatus.COMPLETED;
    } else if (now > end) {
      status = DDLStatus.PASSED;
    } else if ((end - now) < 24 * 60 * 60 * 1000) {
      status = DDLStatus.NEAR;
    } else {
      status = DDLStatus.UNDERGO;
    }

    // 2. è®¡ç®—è¿›åº¦
    let progress = 0.0;
    if (item.isCompleted) {
      progress = 1.0;
    } else {
      const totalDuration = end - start;
      const elapsed = now - start;
      if (totalDuration > 0) {
        progress = Math.max(0, Math.min(1, elapsed / totalDuration));
      } else {
        progress = 0;
      }
    }

    // 3. è®¡ç®—å‰©ä½™æ—¶é—´æ–‡æœ¬
    let timeText = "";
    if (item.isCompleted) {
      timeText = "å·²å®Œæˆ";
    } else {
      const diffMs = end - now;
      if (diffMs < 0) {
        timeText = "å·²é€¾æœŸ " + Math.abs(Math.floor(diffMs / (1000 * 60 * 60))) + " å°æ—¶";
      } else {
        const days = Math.floor(diffMs / (1000 * 60 * 60 * 24));
        const hours = Math.floor((diffMs % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
        if (days > 0) {
          timeText = `${days}å¤© ${hours}å°æ—¶`;
        } else {
          timeText = `${hours}å°æ—¶`;
        }
      }
    }

    const displayProgress = this.progressDir ? progress : 1.0 - progress

    return {
      title: item.name,
      remainingTimeAlt: timeText,
      note: item.note || "",
      progress: displayProgress,
      isStarred: item.isStared,
      status: status,
      dbId: item.id
    };
  }

  private async handleComplete(dbId: number) {
    VibrationUtils.vibrateShort();

    try {
      // 1. è·å–åŸå§‹æ•°æ® (ä¸ºäº†ç®€å•ï¼Œè¿™é‡Œé‡æ–°æŸ¥åº“ï¼Œæˆ–è€…ä½ å¯ä»¥ç»´æŠ¤ä¸€ä¸ª Map<id, DDLItem>)
      // ç”±äºæˆ‘ä»¬ loadData æ—¶åªæ‹¿äº†éƒ¨åˆ†å­—æ®µè½¬ UI Modelï¼Œæœ€å¥½é‡æ–° fetch ä¸€ä¸‹ç¡®ä¿æ‹¿åˆ°æœ€æ–°å…¨é‡å­—æ®µ
      const allItems = await this.repo.getAllDDLs();
      const targetItem = allItems.find(item => item.id === dbId);

      if (!targetItem) {
        console.warn('Item not found for complete');
        return;
      }

      // 2. çŠ¶æ€åè½¬
      const newStatus = !targetItem.isCompleted;
      targetItem.isCompleted = newStatus;

      // 3. æ›´æ–°å®Œæˆæ—¶é—´
      if (newStatus) {
        targetItem.completeTime = new Date().toISOString(); // æˆ–è€…ç”¨ä½ ä¹‹å‰çš„ formatLocalDateTime
        this.confetti.fire();
      } else {
        targetItem.completeTime = "";
      }

      // 4. å†™åº“ + è§¦å‘åŒæ­¥
      await this.repo.updateDDL(targetItem);

      // 5. åˆ·æ–° UI
      // ä¼˜åŒ–ä½“éªŒï¼šè¿™é‡Œå¯ä»¥ç›´æ¥ä¿®æ”¹ this.taskList æœ¬åœ°çŠ¶æ€åšä¹è§‚æ›´æ–°ï¼Œä½†é‡æ–° loadData æœ€ç¨³å¦¥
      await this.loadData();

      promptAction.showToast({
        message: newStatus ? $r('app.string.toast_finished') : $r('app.string.toast_definished')
      });

    } catch (e) {
      console.error(`Complete failed: ${e}`);
      promptAction.showToast({ message: 'æ“ä½œå¤±è´¥' });
    }
  }

  private handleDelete(dbId: number, title: string) {
    VibrationUtils.vibrateMedium();

    // å¼¹å‡ºç¡®è®¤æ¡†
    AlertDialog.show({
      title: 'åˆ é™¤ç¡®è®¤',
      message: `ç¡®å®šè¦åˆ é™¤ä»»åŠ¡ "${title}" å—ï¼Ÿ`,
      autoCancel: true,
      alignment: DialogAlignment.Bottom,
      offset: { dx: 0, dy: -20 },
      primaryButton: {
        value: 'å–æ¶ˆ',
        action: () => {
          this.loadData();
        },
        fontColor: $r('app.color.brand')
      },
      secondaryButton: {
        value: 'åˆ é™¤',
        fontColor: Color.Red,
        action: async () => {
          try {
            await this.repo.deleteDDL(dbId);
            await this.loadData();
            promptAction.showToast({ message: $r('app.string.toast_deletion') });
          } catch (e) {
            console.error(`Delete failed: ${e}`);
            promptAction.showToast({ message: 'åˆ é™¤å¤±è´¥' });
          }
        }
      },
      backgroundBlurStyle: BlurStyle.Thick
    })
  }

  // è¿›å…¥å¤šé€‰æ¨¡å¼
  private enterSelectionMode(firstId: number) {
    VibrationUtils.vibrateShort();
    this.isSelectionMode = true;
    this.selectedIds = [firstId];
  }

  // é€€å‡ºå¤šé€‰æ¨¡å¼
  private exitSelectionMode() {
    this.isSelectionMode = false;
    this.selectedIds = [];
  }

  // åˆ‡æ¢å•ä¸ªé€‰ä¸­çŠ¶æ€
  private toggleSelection(dbId: number) {
    const index = this.selectedIds.indexOf(dbId);
    if (index >= 0) {
      // å·²é€‰ä¸­ -> ç§»é™¤
      this.selectedIds.splice(index, 1);
      // å¦‚æœä¸€ä¸ªéƒ½æ²¡é€‰äº†ï¼Œæ˜¯å¦è‡ªåŠ¨é€€å‡ºï¼Ÿé€šå¸¸ä¸ºäº†ä½“éªŒä¿ç•™æ¨¡å¼ï¼Œç›´åˆ°ç‚¹X
      if (this.selectedIds.length === 0) {
        // å¯é€‰ï¼šthis.exitSelectionMode();
      }
    } else {
      // æœªé€‰ä¸­ -> æ·»åŠ 
      this.selectedIds.push(dbId);
    }
    // è§¦å‘ UI æ›´æ–°ï¼ˆå¦‚æœæ˜¯ç®€å•çš„æ•°ç»„ push å¯èƒ½éœ€è¦é‡æ–°èµ‹å€¼å¼•ç”¨ï¼‰
    this.selectedIds = [...this.selectedIds];

    if (this.selectedIds.length === 0) {
      this.exitSelectionMode();
    }
  }

  // [æ–°å¢] æ‰¹é‡é€»è¾‘ï¼šæ ‡è®°å®Œæˆ
  private async handleBatchComplete() {
    if (this.selectedIds.length === 0) return;

    VibrationUtils.vibrateShort();
    try {
      const allItems = await this.repo.getAllDDLs();
      // æ‰¾åˆ°æ‰€æœ‰é€‰ä¸­çš„é¡¹ç›®
      const targets = allItems.filter(item => this.selectedIds.includes(item.id));

      // æ›´æ–°çŠ¶æ€
      targets.forEach(item => {
        item.isCompleted = true;
        item.completeTime = new Date().toISOString();
      });

      // æ‰¹é‡æ›´æ–°æ•°æ®åº“ (å‡è®¾ repo æ”¯æŒ updateDDLï¼Œå¦‚æœä¸æ”¯æŒæ‰¹é‡ï¼Œéœ€è¦å¾ªç¯ await)
      // å»ºè®® repo å¢åŠ  updateDDLs(items: Array<DDLItem>)
      for (const item of targets) {
        await this.repo.updateDDL(item);
      }

      promptAction.showToast({ message: `å·²å®Œæˆ ${targets.length} é¡¹ä»»åŠ¡` });
      this.exitSelectionMode();
      await this.loadData();
    } catch (e) {
      console.error('Batch complete failed:', e);
    }
  }

  // [æ–°å¢] æ‰¹é‡é€»è¾‘ï¼šå½’æ¡£
  private async handleBatchArchive() {
    if (this.selectedIds.length === 0) return;
    try {
      const allItems = await this.repo.getAllDDLs();
      const targets = allItems.filter(item => this.selectedIds.includes(item.id));

      targets.forEach(item => {
        if (item.isCompleted) item.isArchived = true;
      });

      for (const item of targets) {
        await this.repo.updateDDL(item);
      }

      promptAction.showToast({ message: `å·²å½’æ¡£ ${targets.length} é¡¹ä»»åŠ¡` });
      this.exitSelectionMode();
      await this.loadData();
    } catch (e) {
      console.error('Batch archive failed:', e);
    }
  }

  // [æ–°å¢] æ‰¹é‡é€»è¾‘ï¼šåˆ é™¤
  private handleBatchDelete() {
    if (this.selectedIds.length === 0) return;

    VibrationUtils.vibrateMedium();
    AlertDialog.show({
      title: 'æ‰¹é‡åˆ é™¤',
      message: `ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„ ${this.selectedIds.length} ä¸ªä»»åŠ¡å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚`,
      autoCancel: true,
      alignment: DialogAlignment.Bottom,
      offset: { dx: 0, dy: -20 },
      primaryButton: {
        value: 'å–æ¶ˆ',
        fontColor: $r('app.color.brand'),
        action: () => {}
      },
      secondaryButton: {
        value: 'åˆ é™¤',
        fontColor: Color.Red,
        action: async () => {
          try {
            for (const id of this.selectedIds) {
              await this.repo.deleteDDL(id);
            }
            promptAction.showToast({ message: 'åˆ é™¤æˆåŠŸ' });
            this.exitSelectionMode();
            await this.loadData();
          } catch (e) {
            console.error('Batch delete failed:', e);
          }
        }
      },
      backgroundBlurStyle: BlurStyle.Regular
    });
  }

  private async handleBatchEdit() {
    if (this.selectedIds.length === 0) {
      promptAction.showToast({ message: 'æœªé€‰ä¸­ä»»ä½•ä»»åŠ¡' });
      return;
    }
    const targetId = this.selectedIds[0];
    try {
      const allItems = await this.repo.getAllDDLs();
      const target = allItems.find(item => item.id === targetId);

      if (target) {
        this.editingTask = target;
        this.editingTitle = target.name;
        this.editingNote = target.note || "";

        // ğŸ”¥ è§£ææ—¶é—´å­—ç¬¦ä¸²ä¸º Date å¯¹è±¡
        this.editingStartTime = target.startTime ? new Date(target.startTime) : new Date();
        this.editingEndTime = target.endTime ? new Date(target.endTime) : new Date();

        this.isEditSheetShow = true;
        this.exitSelectionMode();
      } else {
        promptAction.showToast({ message: 'æ‰¾ä¸åˆ°è¯¥ä»»åŠ¡' });
      }
    } catch (e) {
      console.error('Fetch task for edit failed:', e);
      promptAction.showToast({ message: 'æ— æ³•æ‰“å¼€ç¼–è¾‘' });
    }
  }

  private async saveEdit() {
    if (!this.editingTask) return;
    if (!this.editingTitle.trim()) {
      promptAction.showToast({ message: 'ä»»åŠ¡åç§°ä¸èƒ½ä¸ºç©º' });
      return;
    }

    try {
      // ğŸ”¥ ISO æ—¶é—´è½¬æ¢é€»è¾‘ (å¤ç”¨è‡ª AddTaskPage)
      const toLocalISO = (d: Date) => {
        const offset = d.getTimezoneOffset() * 60000;
        const local = new Date(d.getTime() - offset);
        return local.toISOString().slice(0, 19);
      };

      this.editingTask.name = this.editingTitle;
      this.editingTask.note = this.editingNote;
      this.editingTask.startTime = toLocalISO(this.editingStartTime);
      this.editingTask.endTime = toLocalISO(this.editingEndTime);

      await this.repo.updateDDL(this.editingTask);

      this.isEditSheetShow = false;
      await this.loadData();
      promptAction.showToast({ message: 'ä¿®æ”¹å·²ä¿å­˜' });

    } catch (e) {
      console.error('Save edit failed:', e);
      promptAction.showToast({ message: 'ä¿å­˜å¤±è´¥' });
    }
  }

  private formatTime(date: Date): string {
    const pad = (n: number) => n.toString().padStart(2, '0');
    return `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())} ${pad(date.getHours())}:${pad(date.getMinutes())}`;
  }

  private showTimePicker(isStart: boolean) {
    DatePickerDialog.show({
      start: new Date("2000-1-1"),
      end: new Date("2100-12-31"),
      selected: isStart ? this.editingStartTime : this.editingEndTime,
      onAccept: (value: DatePickerResult) => {
        const selectedDate = new Date(value.year!, value.month!, value.day!);
        TimePickerDialog.show({
          selected: isStart ? this.editingStartTime : this.editingEndTime,
          useMilitaryTime: true,
          onAccept: (timeValue: TimePickerResult) => {
            selectedDate.setHours(timeValue.hour, timeValue.minute);
            if (isStart) {
              this.editingStartTime = selectedDate;
            } else {
              this.editingEndTime = selectedDate;
            }
          },
          backgroundBlurStyle: BlurStyle.Regular,
          selectedTextStyle: {
            color: $r('app.color.brand')
          },
          acceptButtonStyle: {
            fontColor: $r('app.color.brand')
          },
          cancelButtonStyle: {
            fontColor: $r('app.color.brand')
          }
        })
      },
      backgroundBlurStyle: BlurStyle.Regular,
      selectedTextStyle: {
        color: $r('app.color.brand')
      },
      acceptButtonStyle: {
        fontColor: $r('app.color.brand')
      },
      cancelButtonStyle: {
        fontColor: $r('app.color.brand')
      }
    })
  }

  @Builder
  taskEditSheet() {
    Column() {
      Column({ space: 16 }) {

        // ä»»åŠ¡åç§°
        TextInput({ placeholder: 'ä»»åŠ¡åç§°', text: this.editingTitle })
          .height(ITEM_HEIGHT)
          .fontSize(16)
          .backgroundColor(this.inputBgColor)
          .borderRadius(COMMON_RADIUS)
          .padding({ left: 16, right: 16 })
          .width('100%')
          .onChange((val) => {
            this.editingTitle = val;
          })

        // å¼€å§‹æ—¶é—´
        TimeInputButton({
          title: 'å¼€å§‹æ—¶é—´',
          content: this.formatTime(this.editingStartTime),
          onClickButton: (): void => this.showTimePicker(true)
        })

        // ç»“æŸæ—¶é—´
        TimeInputButton({
          title: 'ç»“æŸ',
          content: this.formatTime(this.editingEndTime),
          onClickButton: (): void => this.showTimePicker(false)
        })

        // å¤‡æ³¨
        TextArea({ placeholder: 'å¤‡æ³¨ (å¯é€‰)', text: this.editingNote })
          .height(120)
          .fontSize(16)
          .backgroundColor(this.inputBgColor)
          .borderRadius(COMMON_RADIUS)
          .padding({ top: 12, bottom: 12, left: 16, right: 16 })
          .width('100%')
          .onChange((val) => {
            this.editingNote = val;
          })
          .enableKeyboardOnFocus(false) // é˜²æ­¢Sheetä¸€æ‰“å¼€é”®ç›˜å°±å¼¹èµ·é®æŒ¡

        Button('ä¿å­˜').onClick((event: ClickEvent) => {
          this.saveEdit();
        })
          .width('100%')
          .backgroundColor($r('app.color.brand'))

        Blank().height(60)
      }
      .width('100%')
    }
    .width('100%')
    .padding({ left: 16, right: 16 })
  }

  build() {
    Column() {
      if (this.isLoading && this.taskList.length === 0) {
        LoadingProgress()
          .width(50)
          .height(50)
          .margin({ top: 100 })
      } else {
        // ä½¿ç”¨æ–°å°è£…çš„ç»„ä»¶
        TopSafeContainer({ topAvoidHeight: this.topAvoidHeight }) {
          Column() {
            // Refresh åŒ…è£¹ List
            Refresh({ refreshing: $$this.isRefreshing }) {
              List({
                space: 8,
                scroller: this.scroller,
              }) {
                ForEach(this.taskList, (item: TaskUIModel) => {
                  ListItem() {
                    DDLItemCardSwipeable({
                      title: item.title,
                      remainingTimeAlt: item.remainingTimeAlt,
                      note: item.note,
                      progress: item.progress,
                      isStarred: item.isStarred,
                      status: item.status,

                      // å¤šé€‰ Props
                      selectionMode: this.isSelectionMode,
                      selected: this.selectedIds.includes(item.dbId),

                      // æ™®é€šäº¤äº’
                      onComplete: async () => { this.handleComplete(item.dbId) },
                      onDelete: async () => { this.handleDelete(item.dbId, item.title) },

                      // å¤šé€‰äº¤äº’
                      onLongPressSelect: () => {
                        if (!this.isSelectionMode) {
                          this.enterSelectionMode(item.dbId);
                        }
                      },
                      onToggleSelect: () => {
                        this.toggleSelection(item.dbId);
                      }
                    })
                  }
                }, (item: TaskUIModel) => `${item.dbId}_${item.status}_${item.progress}`)

                ListItem() {
                  Divider().color(Color.Transparent).height(80).width('100%')
                }
              }
              .width("100%")
              .height("100%") // æ’‘æ»¡ TopSafeContainer çš„å‰©ä½™ç©ºé—´
              .scrollBar(BarState.Off)
              .edgeEffect(EdgeEffect.Spring, { alwaysEnabled: true })
              .nestedScroll({
                scrollForward: NestedScrollMode.PARENT_FIRST,
                scrollBackward: NestedScrollMode.PARENT_FIRST
              })
              .padding({
                start: LengthMetrics.vp(12), end: LengthMetrics.vp(12)
              })
            }
            .onRefreshing(async () => {
              this.isRefreshing = true
              try {
                await this.repo.syncNow();
              } catch (e) {
                console.error('Manual sync failed');
              }
              await this.loadData();
              this.isRefreshing = false;
            })
          }
        }
      }
    }
    .width("100%")
    .height("100%")
    .bindSheet($$this.isEditSheetShow, this.taskEditSheet(), {
      height: SheetSize.FIT_CONTENT, // åŠå±é«˜åº¦ï¼Œä¹Ÿå¯ä»¥è‡ªå®šä¹‰é«˜åº¦
      dragBar: true,            // æ˜¾ç¤ºæ‹–æ‹½æ¡
      onDisappear: () => {
        this.isEditSheetShow = false;
        this.editingTask = null; // æ¸…ç†æ•°æ®
      },
      blurStyle: BlurStyle.Regular,
      backgroundColor: Color.Transparent,
      title: {
        title: 'ç¼–è¾‘ä»»åŠ¡',
        subtitle: 'ä¿®æ”¹ä»»åŠ¡ä¿¡æ¯ã€‚'
      }
    })
    .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.BOTTOM, SafeAreaEdge.TOP])
  }
}
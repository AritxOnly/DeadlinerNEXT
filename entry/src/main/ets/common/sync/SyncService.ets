import { DatabaseHelper } from '../data/DatabaseHelper';
import { WebUtils, PreconditionFailedError } from '../network/WebUtils';
import { relationalStore, ValuesBucket } from '@kit.ArkData';
import { util } from '@kit.ArkTS';
import { DDLItem } from '../../model/DDLModels';

// å®šä¹‰å¿«ç…§çš„æ•°æ®ç»“æ„ (Interface)
interface SnapshotVer {
  ts: string;
  ctr: number;
  dev: string;
}
interface SnapshotDoc {
  id: number;
  name: string;
  start_time: string;
  end_time: string;
  is_completed: number;
  complete_time: string;
  note: string;
  is_archived: number;
  is_stared: number;
  type: string;
  habit_count: number;
  habit_total_count: number;
  calendar_event: number;
  timestamp: string;
}
interface SnapshotItem {
  uid: string;
  ver: SnapshotVer;
  deleted: boolean;
  doc: SnapshotDoc | null;
}

interface SnapshotInterface {
  ts: string;
  dev: string;
}

interface SnapshotRoot {
  version: SnapshotInterface;
  items: SnapshotItem[]; // æˆ–ä½¿ç”¨ Array<SnapshotItem>
}

export class SyncService {
  private db: DatabaseHelper;
  private web: WebUtils;
  private readonly SNAPSHOT_PATH = "Deadliner/snapshot-v1.json";

  constructor(db: DatabaseHelper, web: WebUtils) {
    this.db = db;
    this.web = web;
  }

  // ä¸šåŠ¡å±‚é’©å­
  onLocalInserted(newLocalId: number) {}
  onLocalUpdated(localId: number) {}
  onLocalDeleting(localId: number) {}

  async syncOnce(): Promise<boolean> {
    console.info("WebDAV: snapshot syncOnce start");
    try {
      return await this.syncSnapshotOnce();
    } catch (e) {
      console.warn(`Sync Failed: ${e}`);
      return false;
    }
  }

  // ============== 1) æ„é€ â€œæœ¬åœ°å¿«ç…§â€ï¼ˆåŒ…å«å¢“ç¢‘ï¼‰ ==============
  private async buildLocalSnapshot(): Promise<SnapshotRoot> {
    const store = this.db.getRdbStore(); // âš ï¸ éœ€è¦åœ¨ DatabaseHelper ä¸­æš´éœ² getRdbStore()
    if (!store) throw new Error("DB not initialized");

    const sql = `
      SELECT
        uid,
        COALESCE(deleted,0)             AS deleted,
        COALESCE(ver_ts,'1970-01-01T00:00:00Z') AS ver_ts,
        COALESCE(ver_ctr,0)             AS ver_ctr,
        COALESCE(ver_dev,'')            AS ver_dev,
        id, name, start_time, end_time, is_completed, complete_time, note,
        is_archived, is_stared, type, habit_count, habit_total_count, calendar_event, timestamp
      FROM ddl_items
    `;

    const resultSet = await store.querySql(sql);
    const items: SnapshotItem[] = [];

    while (resultSet.goToNextRow()) {
      const uid = resultSet.getString(resultSet.getColumnIndex("uid"));
      if (!uid) continue;

      const deleted = resultSet.getLong(resultSet.getColumnIndex("deleted")) !== 0;
      const ver: SnapshotVer = {
        ts: resultSet.getString(resultSet.getColumnIndex("ver_ts")),
        ctr: resultSet.getLong(resultSet.getColumnIndex("ver_ctr")),
        dev: resultSet.getString(resultSet.getColumnIndex("ver_dev"))
      };

      let doc: SnapshotDoc | null = null;
      if (!deleted) {
        doc = {
          id: resultSet.getLong(resultSet.getColumnIndex("id")),
          name: resultSet.getString(resultSet.getColumnIndex("name")),
          start_time: resultSet.getString(resultSet.getColumnIndex("start_time")),
          end_time: resultSet.getString(resultSet.getColumnIndex("end_time")),
          is_completed: resultSet.getLong(resultSet.getColumnIndex("is_completed")),
          complete_time: resultSet.getString(resultSet.getColumnIndex("complete_time")),
          note: resultSet.getString(resultSet.getColumnIndex("note")),
          is_archived: resultSet.getLong(resultSet.getColumnIndex("is_archived")),
          is_stared: resultSet.getLong(resultSet.getColumnIndex("is_stared")),
          type: resultSet.getString(resultSet.getColumnIndex("type")),
          habit_count: resultSet.getLong(resultSet.getColumnIndex("habit_count")),
          habit_total_count: resultSet.getLong(resultSet.getColumnIndex("habit_total_count")),
          calendar_event: resultSet.getLong(resultSet.getColumnIndex("calendar_event")),
          timestamp: resultSet.getString(resultSet.getColumnIndex("timestamp")),
        };
      }

      items.push({ uid, ver, deleted, doc });
    }
    resultSet.close();

    const deviceId = await this.db.getDeviceId();
    const nowTs = new Date().toISOString();

    return {
      version: { ts: nowTs, dev: deviceId },
      items: items
    };
  }

  // ============== 2) åˆå¹¶ï¼ˆLWWï¼šts > ctr > devï¼‰ ==============
  // çº¯é€»è¾‘åˆå¹¶ï¼šä¸æ¶‰åŠ IO
  private mergeSnapshots(local: SnapshotRoot, remote: SnapshotRoot): SnapshotRoot {
    const map = new Map<string, SnapshotItem>();

    // è¾…åŠ©ï¼šåŠ è½½ items åˆ° map
    const load = (root: SnapshotRoot) => {
      if (root.items && Array.isArray(root.items)) {
        for (const item of root.items) {
          map.set(item.uid, item);
        }
      }
    };

    // å…ˆå…¨éƒ¨åŠ è½½ local
    load(local);

    // éå† remote è¿›è¡Œ LWW å†³æ–­
    if (remote.items && Array.isArray(remote.items)) {
      for (const rItem of remote.items) {
        const lItem = map.get(rItem.uid);
        if (!lItem) {
          // æœ¬åœ°æ²¡æœ‰ï¼Œç›´æ¥ç”¨è¿œç«¯
          map.set(rItem.uid, rItem);
        } else {
          // å†²çªï¼šLWW
          if (this.newer(rItem, lItem)) {
            map.set(rItem.uid, rItem);
          }
          // else: local is newer, keep local
        }
      }
    }

    // è½¬æ¢ä¸º Array
    const outItems = Array.from(map.values());

    // è¿”å›åˆå¹¶åçš„ç»“æ„ (ç‰ˆæœ¬å·å– Local çš„å½“å‰æ—¶é—´)
    return {
      version: {
        ts: local.version.ts, // Use local new timestamp
        dev: local.version.dev
      },
      items: outItems
    };
  }

  // ============== 3) åº”ç”¨â€œæœ€ç»ˆå¿«ç…§â€åˆ°æœ¬åœ° DB ==============
  // æå– newer é€»è¾‘ï¼Œæ–¹ä¾¿å¤ç”¨
  // åˆ¤æ–­ a æ˜¯å¦æ¯” b æ–°
  private isVerNewer(aVer: SnapshotVer, bVer: SnapshotVer): boolean {
    if (aVer.ts !== bVer.ts) return aVer.ts > bVer.ts;
    if (aVer.ctr !== bVer.ctr) return aVer.ctr > bVer.ctr;
    return aVer.dev >= bVer.dev;
  }

  // ä¿®æ”¹åŸæœ‰çš„ newer æ–¹æ³•ï¼Œè°ƒç”¨ä¸Šé¢çš„é€šç”¨é€»è¾‘
  private newer(a: SnapshotItem, b: SnapshotItem): boolean {
    return this.isVerNewer(a.ver, b.ver);
  }

  // =====================================================
  // ğŸ”¥ğŸ”¥ğŸ”¥ æ ¸å¿ƒä¿®å¤ï¼šapplySnapshotToLocal ğŸ”¥ğŸ”¥ğŸ”¥
  // =====================================================
  private async applySnapshotToLocal(merged: SnapshotRoot) {
    const store = this.db.getRdbStore();
    if (!store || !merged.items) return;

    store.beginTransaction();
    let insertCount = 0;
    let updateCount = 0;
    let skipCount = 0; // ç»Ÿè®¡è¢«è·³è¿‡çš„ï¼ˆä¿æŠ¤æœ¬åœ°æ–°ä¿®æ”¹çš„ï¼‰

    try {
      for (const item of merged.items) {
        const uid = item.uid;
        const mergedVer = item.ver; // è¿™æ˜¯åŒæ­¥è®¡ç®—å‡ºçš„ç‰ˆæœ¬
        const deleted = item.deleted;

        // 1. æŸ¥è¯¢æœ¬åœ°å½“å‰çš„å®é™…çŠ¶æ€
        const predicates = new relationalStore.RdbPredicates("ddl_items");
        predicates.equalTo("uid", uid);
        const resultSet = await store.query(predicates);
        const exists = resultSet.goToFirstRow();

        let localId: number | null = null;
        let currentLocalVer: SnapshotVer | null = null;

        if (exists) {
          localId = resultSet.getLong(resultSet.getColumnIndex("id"));
          // è¯»å–å½“å‰ DB é‡Œçš„ç‰ˆæœ¬å·
          currentLocalVer = {
            ts: resultSet.getString(resultSet.getColumnIndex("ver_ts")),
            ctr: resultSet.getLong(resultSet.getColumnIndex("ver_ctr")),
            dev: resultSet.getString(resultSet.getColumnIndex("ver_dev"))
          };
        }
        resultSet.close();

        // 2. ğŸ›¡ï¸ğŸ›¡ï¸ğŸ›¡ï¸ ç«æ€ä¿æŠ¤ ğŸ›¡ï¸ğŸ›¡ï¸ğŸ›¡ï¸
        // å¦‚æœæœ¬åœ°å­˜åœ¨ï¼Œä¸”æœ¬åœ°ç°åœ¨çš„ç‰ˆæœ¬ æ¯” åˆå¹¶ç»“æœçš„ç‰ˆæœ¬ è¿˜è¦æ–°
        // è¯´æ˜åœ¨åŒæ­¥æœŸé—´ï¼Œç”¨æˆ·ä¿®æ”¹äº†è¿™æ¡æ•°æ®ã€‚
        // æ­¤æ—¶ç»å¯¹ä¸èƒ½è¦†ç›–ï¼Œä¿ç•™æœ¬åœ°çš„ä¿®æ”¹ï¼
        if (currentLocalVer && this.isVerNewer(currentLocalVer, mergedVer)) {
          console.warn(`[Sync] Race detected for uid=${uid.slice(0,6)}. Local is newer, skipping overwrite.`);
          skipCount++;
          continue; // è·³è¿‡è¿™ä¸€æ¡çš„å†™å…¥
        }

        // 3. æ­£å¸¸å†™å…¥é€»è¾‘ (å’Œä¹‹å‰ä¸€æ ·)
        const bucket: ValuesBucket = {};
        bucket["ver_ts"] = mergedVer.ts;
        bucket["ver_ctr"] = mergedVer.ctr;
        bucket["ver_dev"] = mergedVer.dev;

        if (deleted) {
          bucket["deleted"] = 1;
          if (exists) {
            const upPred = new relationalStore.RdbPredicates("ddl_items");
            upPred.equalTo("id", localId);
            await store.update(bucket, upPred);
            updateCount++;
          } else {
            // æ’å…¥å¢“ç¢‘
            bucket["uid"] = uid;
            bucket["name"] = "(deleted)";
            bucket["start_time"] = ""; bucket["end_time"] = ""; bucket["complete_time"] = "";
            bucket["note"] = ""; bucket["type"] = "task"; bucket["timestamp"] = mergedVer.ts;
            bucket["is_completed"] = 1; bucket["is_archived"] = 1; bucket["is_stared"] = 0;
            bucket["habit_count"] = 0; bucket["habit_total_count"] = 0; bucket["calendar_event"] = -1;
            await store.insert("ddl_items", bucket);
            insertCount++;
          }
        } else {
          const doc = item.doc!;
          bucket["deleted"] = 0;
          bucket["name"] = doc.name;
          bucket["start_time"] = doc.start_time;
          bucket["end_time"] = doc.end_time;
          bucket["is_completed"] = doc.is_completed;
          bucket["complete_time"] = doc.complete_time;
          bucket["note"] = doc.note;
          bucket["is_archived"] = doc.is_archived;
          bucket["is_stared"] = doc.is_stared;
          bucket["type"] = doc.type;
          bucket["habit_count"] = doc.habit_count;
          bucket["habit_total_count"] = doc.habit_total_count;
          bucket["calendar_event"] = doc.calendar_event;
          bucket["timestamp"] = doc.timestamp;

          if (exists) {
            const upPred = new relationalStore.RdbPredicates("ddl_items");
            upPred.equalTo("id", localId);
            await store.update(bucket, upPred);
            updateCount++;
          } else {
            bucket["uid"] = uid;
            await store.insert("ddl_items", bucket);
            insertCount++;
          }
        }
      }
      store.commit();
      console.info(`[Sync] Apply done. Ins:${insertCount}, Upd:${updateCount}, Skipped(Race):${skipCount}`);
    } catch (e) {
      console.error(`[Sync] Apply failed: ${e}`);
      store.rollBack();
    }
  }

  private async syncSnapshotOnce(): Promise<boolean> {
    const path = this.SNAPSHOT_PATH;
    const textEncoder = new util.TextEncoder();
    const textDecoder = util.TextDecoder.create('utf-8');

    // ================= 1. æ„å»ºæœ¬åœ°å¿«ç…§ =================
    const localSnap = await this.buildLocalSnapshot();

    // ğŸ” ä¾¦æ¢æ—¥å¿—ï¼šçœ‹çœ‹æœ¬åœ°åˆ°åº•æŸ¥åˆ°äº†ä»€ä¹ˆï¼Ÿ
    const localTaskCount = localSnap.items.length;
    if (localTaskCount > 0) {
      // æ‰“å°ç¬¬ä¸€ä¸ªä»»åŠ¡çš„ UID å’Œ VerTSï¼Œç¡®è®¤ä¸æ˜¯ 1970
      const first = localSnap.items[0];
    }

    // ================= 2. HEAD æ¢æµ‹ =================
    let remoteCode = 0;
    try {
      const WebHead = await this.web.head(path);
      remoteCode = WebHead.code;
    } catch (e) {
      return false;
    }

    // ================= 3. å¤„ç† 404 (åˆå§‹åŒ–äº‘ç«¯) =================
    if ([404, 409, 410].includes(remoteCode)) {
      try {
        await this.web.ensureDir("Deadliner");
        const jsonStr = JSON.stringify(localSnap);
        const bytes = textEncoder.encode(jsonStr);

        const res = await this.web.putBytes(path, bytes, null, true); // å‡è®¾ putBytes è¿”å› responseï¼Œå¦‚æœæ²¡è¿”å›ä¹Ÿæ²¡äº‹
        return true;
      } catch (e) {
        return false;
      }
    }

    // ================= 4. GET ä¸‹è½½è¿œç«¯ =================
    let remoteSnap: SnapshotRoot;
    let currentEtag: string | null = null;
    try {
      const webBytes = await this.web.getBytes(path);
      const bytes = webBytes.bytes;
      currentEtag = webBytes.etag;

      try {
        // 1. è§£ç 
        const jsonStr = textDecoder.decodeToString(bytes); // API 9+ æ¨èç”¨ decodeToString
        // å¦‚æœæ˜¯æ—§ APIï¼Œç”¨: textDecoder.decode(bytes)

        // 2. è§£æ
        remoteSnap = JSON.parse(jsonStr) as SnapshotRoot;

        // 3. ğŸ›¡ï¸ğŸ›¡ï¸ğŸ›¡ï¸ å®‰å…¨ç†”æ–­æ£€æŸ¥ ğŸ›¡ï¸ğŸ›¡ï¸ğŸ›¡ï¸
        // å¦‚æœè¿œç«¯æ˜æ˜æœ‰æ•°æ®ï¼ˆ>1KBï¼‰ï¼Œä½†è§£æå‡ºæ¥ items å´æ˜¯ undefined æˆ–ç©ºï¼Œ
        // è¯´æ˜è§£æå¤±è´¥ï¼Œç»å¯¹ä¸èƒ½ç»§ç»­åˆå¹¶ï¼Œå¦åˆ™ä¼šæ¸…ç©ºäº‘ç«¯ï¼
        if (bytes.length > 1000 && (!remoteSnap.items || !Array.isArray(remoteSnap.items))) {
          console.error(`[Sync] CRITICAL: Invalid remote JSON. Sync aborted.`);
          return false;
        }

        // å¦‚æœè§£æå‡ºæ¥çš„ items æ˜¯ null (ä¾‹å¦‚åˆšåˆå§‹åŒ–çš„æ–‡ä»¶)ï¼Œç»™ä¸ªç©ºæ•°ç»„
        if (!remoteSnap.items) {
          remoteSnap.items = [];
        }

      } catch (e) {
        return false;
      }
    } catch (e) {
      return false;
    }

    // ================= 5. åˆå¹¶ =================
    let merged = this.mergeSnapshots(localSnap, remoteSnap);

    let mergedJson = JSON.stringify(merged);
    // ğŸ”¥ ä¿®å¤ç‚¹ï¼šä½¿ç”¨ encodeIntoUint8Array
    let mergedBytes = textEncoder.encode(mergedJson);

    // ================= 6. PUT ä¸Šä¼  =================
    try {
      // è¿™é‡Œå‡è®¾ä½ çš„ WebUtils.putBytes èƒ½å¤ŸæŠ›å‡ºé”™è¯¯æˆ–è€…è¿”å›çŠ¶æ€
      await this.web.putBytes(path, mergedBytes, currentEtag, false);
    } catch (e) {
      if (e instanceof PreconditionFailedError) {
        console.warn("[Sync] Conflict 412, syncing again next time...");
      }
    }

    // ================= 7. åº”ç”¨å›æœ¬åœ° =================
    await this.applySnapshotToLocal(merged);
    return true;
  }
}